\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{float}


\usepackage{titlesec}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}









\title{SLM Circuit Simulator Log}
\author{Sam Taylor, Maximus Wickham , Leonardo Garofalo}
\date{June 2020}

\pagestyle{fancy}
\fancyhf{}
\rhead{SLM Solutions}
\lhead{Circuit Simulator}
\rfoot{Page \thepage}

\graphicspath{ {./images/} }
\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Engineering Design Process}
\flushleft

\subsection{Outline of technical problem to be solved:}
\flushleft

\smallbreak
Write a software package that performs a transient simulation of a circuit, like LTspice. The main elements of such a system are described below:
\newline
\smallbreak
1. Parse the netlist file using reduced SPICE format.
\newline
2. Set up the simulation (Transient Analysis , DC Bias Point Analysis)
\newline
3. Construct and solve the conductance matrix
\newline
4. Process voltage sources
\newline
5. Write the output
\newline
6. Add support for non-linear components (advanced)
\newline
\mediumbreak 

Key Evaluation points:
\newline
1. Accuracy: compare the outputs to pen and paper solutions. 
\newline
2. Efficiency: find how long the simulation takes and, by estimating the power consumption of your computer.

\subsection{Software Requirements Specification:}
\flushleft
\textbf{Outline:} A circuit Simulation that produces transient analysis for circuits containing energy storage devices , diodes and transistors . With reasonable accuracy and speed.

\bigbreak

\textbf{Functional Requirements}

\newline

1. Give Node Voltages of a complete circuit within 1 percent of Spice
\newline
2. Evaluate Current flowing through each component within 1 percent of Spice
\newline
3. Perform analysis for passive, energy storage devices , diodes and transistors.
\newline
4. Take input from a reduced spice netlist file.
\newline
5. Output analysis to an output file.


\bigbreak

\textbf{Non-Functional Requirements}
\newline
\textbf{1. The software must be capable of analyse different kinds of circuits.}
\newline
We have seen from our testing section the range of circuits that can be analysed by our simulator , the components implemented 
\smallbreak
\textbf{2. The software must be able to perform the analysis in a time efficient way.}


\newpage
\subsection{Design Process and Project management}

We chose to use the Scrum framework to manage our collaboration during the project. We initially populated the project backlog with details from the specification and our design overview. Each morning (at varying times) we held a thirty minute scrum to inform each other what we work we would be doing that day. At the end of each day we held a second meeting to discuss what was achieved and what problems we encountered updating the backlog with completed and new tasks.
We also held a bi-weekly sprint meeting where we determined the milestone and objectives of that sprint. We did not use a sprint backlog just kept a single updated backlog. 

\begin{figure}[h]
    \caption{Scrum Framework work pattern}
    \centering
    \includegraphics[width=\textwidth]{images/ScrumFramework.jpg}
    \label{fig:Scrum}
\end{figure}
We also used a timeline to keep general project discipline and keep goals realistic to the final deadline. This was used to ensure we were not implementing more functionality beyond our ability to produce a write up.
\begin{figure}[h]
    \caption{Snapshot of Onenote backlog}
    \centering
    \includegraphics[width=0.8\textwidth]{images/Backlog.PNG}
    \label{fig:BackLog}
\end{figure}
We used Git a distributed version-control system for tracking changes in source code during our software development. Link to repo in references. 

\newpage
\subsection{Design Process Review}

Our initial idea was to rapidly prototype a number of key functions for our design such as KCL solver \ref{KCLsolver}, transient solver \ref{ssec:TransientSolver} and few components so that we could get immediate results and would be able to tackle any troubling theory quickly. This proved to work well and allowed us to maintain steady project momentum at a daunting stage in development. Whilst also giving us some swift functionality to  plan the design around.  A drawback however was that later on when refining prototype functions it became an issue that, aspects of the prototype function had been relied upon or compensated for in other areas of code. Leading to some redundant / artifact code that had to be removed.
\medbreak
It was also confusing at time which to prioritise : Accuracy or speed/efficiency , therefore we found that some functions had conflicting goals. In reflection i would have placed a preference order on criterion of the specification to highlight which should take precedence when implementing.  
\smallbreak
\begin{figure}[h]
    \caption{Timeline of project progression}
    \centering
    \includegraphics[width=0.6\linewidth]{images/Timeline.PNG}
    \label{fig:Timeline}
\end{figure}
We decided to use this timeline over a Gannt chart as is Incorporated well with our scrum model.
Reviewing our timeline and working procedures revealed to me some key points to work better on projects in future:
\begin{itemize}
    \item Find a better method for communicating changes made to each others code.
    \item Set Clear data structures / types to be passed between functions. (Establish a universal format)
    \item Have project discipline and maintain focus on tasks that are expected to be complete.
\end{itemize}
\newpage
\section{High Level Program Design }
\subsection{Overview of Design}
\textbf{Data Flow / Structure}
\newline
The input net list is in the form of a txt file with two output files: output\verb|_|current and output\verb|_|voltage . The output files are in a CSV format with each line denoting a time instance. The parser creates a circuit object passes that as well as the transient time step and time period. Transient analysis then loops through the Transient solver recursively performing KCL solver. From this we agreed upon data inputs and outputs to each function.

\begin{figure}[h]
    \caption{Overview of data flow}
    \centering
    \includegraphics[width=0.65\textwidth]{images/Overview.PNG}
    \label{fig:AlgoOverview}
\end{figure}

The circuit.obj is passed by reference to each function , with its fields being updated or modified as the simulation progresses. 

\newpage
\subsection{Circuit Class}
The Circuit class is what we used to represent an electrical circuit. The object task is to encapsulate information about each component specified in the input file, its connections with other components, the voltages at each node as well as other simulation parameters.\\
It holds a number of key fields:
\medbreak
\noindent\begin{minipage}{.5\linewidth}
\begin{itemize}
    \item a vector$<$Component*$>$ is used to contain information about each Component in the circuit
    \item a vector$<$Node$>$ is used to contain information about each Node in the circuit and all the nodes attached to it
    \item a vector$<$double$>$ is used to contain information about the voltages at each node in the circuit
\end{itemize}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{itemize}\break
    \item GMIN is a parameter to indicate the minimum conductance allowed in the circuit
    \item ABSTOL,RELTOL and max\verb|_|iterations are parameters needed for convergence of BJTs and Diodes
\end{itemize}
\end{minipage}
\bigbreak
A circuit object dynamically changes during a simulation. Each macro-block has access to it in order to carry out the simulation or print out the node voltages and the currents through each branch.\\
The vector$<$Component*$>$ and the vector$<$Nodes$>$ is instantiated before the simulation is run according to the input file. During each timestep all the non-linear components are updated and the voltages at each node evaluated. The vector$<$Node$>$ is then used to evaluate the currents through each branch. The updated circuit object is then used as a starting point to evaluate the node voltages at the next time instance.
\paragraph{Node Struct}
The node struct is present in the circuit object as it is necessary to work out currents through voltage sources easily. The struct contains a vector of components, representing the components at that node as well as an index that labels that node. The circuit then has a vector of nodes representing each of the nodes in the circuit. This vector is formed when the circuit is constructed in the parser. 

\bigbreak
See Source code: Circuit.hpp for implementation.

\newpage
\subsection{Why Eigen3}
We decided to include the \textit{Eigen3} library to deal with matrices operations.\\
We chose Eigen3 because:
\subparagraph{Eigen3 is versatile}
\begin{itemize}
    \item it supports all matrix sizes, from small fixed-size matrices to arbitrarily large dense matrices, and even sparse matrices.
    \item It supports various matrix decompositions methods
\end{itemize}
\subparagraph{Eigen3 is fast}
\begin{itemize}
    \item Fixed-size matrices are fully optimized: dynamic memory allocation is avoided
    \item For large matrices, special attention is paid to cache-friendliness.
\end{itemize}
\subparagraph{Eigen3 is reliable and easy to use}
\begin{itemize}
    \item used by Google and many other tech-lead companies
    \item has intuitive and easy to grasp documentation
\end{itemize}
\newpage
\subsection{GUI and main}\label{ssec:GUIandmain}
We chose to produce a GUI and a maker tool to help simplify the build process for development projects across different platforms as we were using a range of platform for development. It automates the generation of Makefiles so that only a few lines of information are needed to create each Makefile. We chose to use QT , a free and open-source widget toolkit for creating graphical user interfaces as well as cross-platform applications. This allowed us to have a single application environment where we could easily test and deploy a distributable for our work.
\bigbreak
\begin{figure}[h]
    \caption{Application example operation displaying voltage at node 2 for a full wave rectifier}
    \centering
    \includegraphics[width=1\textwidth]{images/AppEx.PNG}
    \label{fig:AppEx}
\end{figure}
Hence this allowed us to satisfactorily test and ensure correct operation of our program. Ensuring that all was functioning as expected. Further it was designed in such a way to operate completely independently of the main program. Essentially the Qt app only provides output and reads output from the main analysis program. Aside from that it is entirely possible to perform complete analysis from the terminal.
\bigbreak
The Qt container also gave us the ability to also run our simulator on multiple platforms which gave us a secure testing platform and scope to distribute the program to as many users as possible.

\newpage
\section{Component Models}
The following section will go through the models and implementations for each Electrical component in our simulation.
A Component is a class with a name, an anode, a cathode and some specialized methods and data-members
\begin{figure}[h]
    \caption{Component Inheritance tree}
    \centering
    \includegraphics[width=12cm]{images/Comphpp1.jpg}
    \label{fig:Comp}
\end{figure}

\subsection{Current Components}
Current components , have virtual function called get\verb|_|current() that allows the any component that is a current component to be cast into a current component and have its get\verb|_|current function called , conveniently allowing differentiation between components of different properties in KCL solver and avoiding needless selection.
\bigbreak
See source code: Component.hpp (Current Component) for implementation.
\medbreak


\subsubsection{Resistor}
The resistor is a simple component to implement with respect to our design hence a simple self produced model was used. The class contained a resistance and conductance variables and a get\verb|_|current method which took the node voltages and resistance of the component. \bigbreak\\$Current = \frac{VAnode - VCathode}{R}$
\bigbreak
See source code: Component.hpp (Resistor) for implementation.
\newpage
\subsubsection{Capacitor}
The capacitor is an energy storage component, hence the transient analysis of such a component requires the use of a companion model to be formed in order to solve the integral needed for a capacitor. Multiple were researched\cite{NumericalMethods} that can represent both the capacitor and inductor: Backward Euler , Forward Euler, Gear and the Trapezoidal Rule\cite{IntegrationMethods}. We chose to implement the Backward Euler method as it is very stable whilst being fairly easy to implement. Many versions of Spice also also it by default. 
The Backward Euler rule is a follows: \bigbreak
$Y_{n+1} = Y_n + \Delta x\frac{dY_{n+1}}{dx}$ \bigbreak
Using this rule it is possible to derive the next voltage of a capacitor from its differential equation:
\bigbreak

$I = C\frac{dv}{dt}$
\medbreak
$V_{n+1} = V_n + \Delta t\frac{dV_{n+1}}{dt}$
\medbreak
$V_{n+1} = V_n + \frac{\Delta t}{C}i_{n+1}$
\medbreak
$I_{n+1} = \frac{C}{\Delta t}(V_{n+1}-V_n)$
\bigbreak

Therefore, we can interpret this simplified equation into a companion model that gives us the circuit in figure \ref{fig:CapModel}. The Backward Euler method represents each change as a straight line and so the capacitor can be represented as a current source in parallel with a resistor. The values used in the circuit result in the calculation of the voltage across the capacitor being the solution to the next iteration of the Backward Euler method: 

\begin{figure}[h]
    \caption{Capacitor Model}
    \centering
    \includegraphics[width=0.7\textwidth]{images/CapModel.jpg}
    \label{fig:CapModel}
\end{figure}

\bigbreak

\noindent\begin{minipage}{.4\linewidth}
\begin{equation}
  Conductance = \frac{C}{\Delta t}
\end{equation}
\end{minipage}%
\begin{minipage}{.7\linewidth}
\begin{equation}
  LinearCurrent = Conductance*V_n
\end{equation}
\end{minipage}

\bigbreak 

Thus for our transient analysis we now have a linear model for our conductance matrix. Conductance remains constant from the start of the simulation to finish. However the value of Linear Current is updated on every time step, as the value of Vn changes from from step to step.
\bigbreak 
See source code: Component.hpp (Capacitor) for implementation


\subsubsection{Inductor}
The inductor is the dual of the capacitor hence similar results apply (Same Backward Euler model). We end up with a similar derivation:
\bigbreak

$V = L\frac{di}{dt}$
\medbreak
$I_{n+1} = I_n + \Delta t\frac{dI_{n+1}}{dt}$
\medbreak
$I_{n+1} = I_n + \frac{\Delta t}{L}V_{n+1}$

\bigbreak

Thus we can interpret this simplified equation into a companion model, that gives us: 

\bigbreak

\begin{figure}[h]
    \caption{Inductor Model}
    \centering
    \includegraphics[width=0.7\textwidth]{images/InductorModel.jpg}
    \label{fig:InductorModel}
\end{figure}

\noindent\begin{minipage}{.5\linewidth}
\setcounter{equation}{0}
\begin{equation}
  Conductance = \frac{\Delta t}{L}
\end{equation}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{equation}
  LinearCurrent = i_n
\end{equation}
\end{minipage}

\bigbreak

Thus for our transient analysis we now have a linear model for our conductance matrix. Conductance remains constant from the start of the simulation to finish. However the value of Linear Current is the result of the previous calculation thus In is the summation of all previous $ N * \frac{\Delta t}{L}V_{n+1}$

\bigbreak

See source code: Component.hpp (Inductor) for implementation.

\newpage

\subsubsection{Final Energy Storage component models}
Both components have a range of companion models associated with them. 

\begin{figure}[h]%
    \centering
    \subfloat[Capacitor Models]{{\includegraphics[width=5cm]{images/CapModels.PNG} }}%
    \qquad
    \subfloat[Inductor Models]{{\includegraphics[width=5cm]{images/IndModels.PNG} }}%
    \caption{Energy Storage Models}%
    \label{fig:example}%
\end{figure}

Our choice of model was made to ensure accuracy and speed of simulation. Trapezoidal calculation introduces error due to over and under estimation of area, whilst also being computationally intense. Backward Euler was chosen as it is far more accurate than Forward Euler. Our model represents this Euler method which allowed for increased speed and accuracy. Both used Norton equivalent models as conductance was our preferred calculation parameter (instead of resistance) hence, a slight accuracy error may occur in the capacitor model as computers may have trouble dividing by too small a $\Delta t$.

\subsubsection{Current Source}
A Current Source is implemented by adding constants to the vector of currents. The constant is returned by the get\_current method.\bigbreak
See source code: Component.hpp (Current Source) for implementation
\subsubsection{Voltage Controlled Current Source}
A Voltage Controlled Current Source is characterized by the equation $ Current = gain\cdot(V_{control\_anode}-V_{control\_cathode})$
\bigbreak
See source code: Component.hpp (Voltage Controlled Current Source) for implementation
\newpage
\subsection{Voltage Components}
Voltage components , have virtual function called get\verb|_|Voltage() that allows the any component that is a voltage component to be cast into a voltage component and have its get\verb|_|Voltage() function called , conveniently allowing differentiation between components of different properties in KCL solver and avoiding needless selection.
\bigbreak
See source code: Component.hpp (Voltage Component) for implementation

\subsubsection{Voltage Source}
A voltage source is characterized by the equation $V_{anode}-V_{cathode}=V_{src}$. \bigbreak
See source code: Component.hpp (Voltage Source) for implementation

\subsubsection{Voltage Controlled Voltage Source}
A Voltage Controlled Voltage Source is characterized by the equation
$V_{anode}-V_{cathode}=gain\cdot(V_{control\_anode}-(V_{control\_cathode})$.
\bigbreak
See source code: Component.hpp (Voltage Controlled Voltage Source) for implementation


\subsubsection{AC Voltage Source}
The AC voltage source is a source with sinusoidal voltage output that is set by a SINE waveform in SPICE, the source has a number of parameters: Amplitude , Frequency , DC Offset and a current voltage (Phase was omitted as we only modelled SINE waves without). The component was simple to implement and required a simple Set and Get methods to access the current voltage. 
The Set function changes the value of current\verb|_|Voltage depending on the Current Time: Current Time = T
\medbreak

$ CurrentVoltage = V_{Amp}  \sin{(2\pi f T)} + Dc $
\medbreak
The get function then returns this value of current Time allowing it to be updated and displayed.
\bigbreak
See source code Component.hpp (AC Voltage Source) for implementation.
\newpage

\subsection{Semiconductor Components}
\subsubsection{Diode}\label{ssec:Diode}
Unlike the other components discussed so far, diodes do not have a linear relationship between voltage and current. This means that using a linear matrix method to solve the circuit would not be possible when non-linear components such as diodes are present. However, due to the exponential formula for the current through a diode an analytical solution is often far too complex and even impossible. Therefore, the iterative Newton-Raphson technique for solving equations had to be used\cite{DiodeModel}. This algorithm is discussed in detail in the Transient Solver section, with it resulting in a linear implementation of the diode component.
\\
Inside SPICE the current equation of a diode is dependent on several parameters. 
\begin{itemize}
    \item Is
    \item N
    \item BV
    \item Rs
    \item GMIN (universal constant)
\end{itemize}
Using these parameters the current through the diode is broken down into three sections. When the voltage across the diode is greater than $-5NVt$ (where $Vt = kT/q$ and is taken universally within the simulator to be 0.0258641) the equation is the standard Shockley equation.\bigbreak \\ $I = Is*(e^{\frac{Vd}{N*Vt}}-1) + Vd*GMIN$. \\\bigbreak GMIN is simply the min conductance of the diode and represents a resistor in parallel to it aiding in convergence. When Vd is less than $-5NVt$ but greater than BV the exponential is not worked out as it is insignificant next to the effect of GMIN. BV represents the breakdown voltage of the diode and when VD is less than it the equation is modified.\bigbreak
\\$I = -Is*(e^{-\frac{BV+Vd}{N*Vt}}-1+\frac{BV}{Vt})$\\\bigbreak
The value Rs represents the connection resistances of the diode and is equivalent to a resistor in series with the diode described by these equations. The diode that is implemented in our simulator is the 1N194 and has values taken from LTspice of $Is=2.5n$, $Rs=0.568$, $N=1.752$ and $BV = -70$.  
\\
In order for the iterative technique to be implemented an ideal diode has to be implemented as a current source in parallel with a resistor, as any linear voltage current relationship can be simplified to this. It would be possible to represent the diode as a voltage source and resistor in parallel but this would make generating matrix coefficient harder due to the presence of an extra node. It would also be slower due to voltage sources being more complex to compute in our matrix solver algorithm. Three functions had to be implemented to set the values of the current source and resister which were as follows.
\begin{itemize}
    \item Set Vd (double \_vd)
    \item Set id0 (double (\_ido)
    \item Set Conductance
\end{itemize}

Set Vd and Set ido are simply needed to set the current through the diode and voltage across it at the last iteration. Set Conductance is needed to set the conductance of the resistor in the linear model. This had to be equal to the partial derivative of the diode current equation with respect to voltage. This partial derivative is broken down into three sections to match the current equation described above with the section relating to the Shockley equation as follows.\bigbreak
\\$G = \frac{Is}{N*Vt}*e^{\frac{Vd}{N*Vt}}$\\\bigbreak
Unfortunately, the conductance and linear current of the diode could not be used immediately inside of the KCL solver algorithm. This is due to the presence of the a series resister in the diode model. One approach to this problem could have been to add a resistor in series with the diode in the circuit, but this would have added another node thus increasing the complexity of our matrix and slowing down the simulation. Instead the dependence of the current through the diode on the voltage at each node is calculated as well as the constant current emitted by it. Three functions were made to implement this. 
\begin{itemize}
    \item Get Anode Coefficient
    \item Get Cathode Coefficient
    \item Get Constant Coefficient
\end{itemize}
The outputs of these function can be read directly into the conductance matrix and current vector within the KCL algorithm. The derivation for these values is shown using the circuit in figure \ref{fig:diode}\bigbreak
\\$(V_0-V_1)*G_s = (V_1-V_2)*G_l - I_l$\bigbreak
\\$V_1 = \frac{V_0*G_s + V_2*G_l - I_l}{G_s+G_l}$\bigbreak
\\And so the current passing through $G_s$ is given by:\bigbreak
\\$V_0*Gs - \frac{V_0*G_s^2}{G_s+G_r} - \frac{V_2*G_r*G_s}{G_s+G_r} + \frac{I_l*G_s}{G_s+G_r}$\bigbreak
\\Thus the coefficients can be taken from this equation. \bigbreak
\\$V_0$ coefficient is given by $Gs - \frac{G_s^2}{G_s+G_r}$\bigbreak
\\$V_2$ coefficient is given by $- \frac{G_r*G_s}{G_s+G_r}$\bigbreak
\\The constant coefficient is given by $\frac{I_l*G_s}{G_s+G_r}$\bigbreak
These three terms completely describe the diode model with the KCL solver algorithm as the GMIN value is added to the value of $G_l$. The presence of this series diode presents another problem though. In order for the linear current and conductance to be set by the Transient Solver algorithm the voltage across the diode is needed. However, this is no-longer simply the voltage across the terminals due to the presence of Rs. In order to account for this when setting the voltage across the diode the voltage across Rs, calculated using the current through the diode is subtracted from the voltage between the nodes. 
\begin{figure}[h]
    \caption{Linear Model of Diode}
    \centering
    \includegraphics[width=0.25\textwidth]{images/DiodeCircuit.png}
    \label{fig:diode}
\end{figure}
\bigbreak
See source code: Component.hpp (Diode) for implementation
\newpage

\subsubsection{BJT}\label{ssec:BJT}
In order to model BJT's within our simulator we used the the Ebers Moll model\cite{BJTModel}. This consists of two diodes in parallel with two current dependent current sources. The current sources each provide a current proportional to the current passing through the corresponding diode as can be seen in figure \ref{fig:EbersMoll}. The advantage of using the Ebers Moll model is that is works over the entire operating range of the BJT meaning only one model has to be used. The model's only nonlinear component is a diode which also provides an advantage in that we can use our preexisting method for finding a solution to circuits with diodes present. \\
Within Spice a BJT is defined by several parameters with the ones we used being: 
\begin{itemize}
    \item $I_S$
    \item $R_b$
    \item $R_c$
    \item $R_e$
    \item $\beta_r$
    \item $\beta_f$
\end{itemize}
$I_s$ is needed for the diode equations, both diodes use the same value and $R_b, R_c$ and $R_e$ are the connection resistance of each of the terminals. $\beta_f$ and $\beta_r$ are used to define the current gains, these relate to $\alpha_r$ and $\alpha_f$ with this equation. \bigbreak
$\beta = \frac{\alpha}{1-\alpha}$\bigbreak
\begin{figure}[h]
    \caption{Ebers Moll Model}
    \centering
    \includegraphics[width=0.5\textwidth]{images/EbersMoll.png}
    \label{fig:EbersMoll}
\end{figure}
When the connection resistors are added to the model and the diodes are displayed using their linear models from the iterative algorithm the circuit becomes that shown in figure \ref{fig:LinearEbersMoll}. As in the case of the diode adding connection resistors makes calculating the dependence of current on node voltages more complicated. We could simply add connection resistors directly in our circuit but this would increase the number of nodes and so the complexity of our matrix. In order to represent the BJT's in the conductance matrix the current at each node will need to be calculated in terms of the voltage at each node and a constant term. In order to derive these terms we first started with a set of KCL equations at each of the inner nodes. \bigbreak
$(V_c-V_1)*G_c = (V_1-V_0)*G_r - I_r + \alpha_r*I_f + \alpha_r*G_f*(V_0-V_2)$\bigbreak
$(V_c-V_1)*G_c + (V_e-V_2)*G_e + (V_b-V_2)*G_b = 0$\bigbreak
$(V_e-V_2)*G_e = (V_2-V_0)*G_f - I_f + \alpha_f*I_r + \alpha_f*G_r*(V_0-V_1)$\bigbreak
These equations then need to be rearranged to give $V_0$, $V_1$ and $V_2$ in terms of the other variables so the current at each node can be calculated. This proved difficult to do by hand and so MatLab was used to rearrange the equations. This resulted in these equations.\bigbreak
$D = G_b*G_c*G_e + G_b*G_c*G_f + G_c*Ge*G_f + G_b*Ge*Gr + G_b*G_f*Gr + G_c*Ge*Gr + G_c*G_f*Gr + Ge*G_f*Gr
            - \alpha_f*Gc_*G_e*G_r - \alpha_r*G_c*G_e*G_f - \alpha_f*\alpha_r*G_b*G_f*G_r - \alpha_f*\alpha_r*G_c*G_f*G_r - \alpha_f*\alpha_r*G_e*G_f*G_r$\bigbreak
$V_0 = (\alpha_f*G_c*G_e*I_r - G_c*G_e*I_r - G_c*G_f*I_r - G_e*G_r*I_f - G_c*G_e*I_f + \alpha_r*G_c*G_e*I_f + G_b*G_c*G_e*V_b + G_b*G_c*G_f*V_b + G_c*G_e*G_f*V_e + G_b*G_e*G_r*V_b + G_b*G_f*G_r*V_b + G_c*G_e*G_r*V_c + G_c*G_f*G_r*V_c + G_e*G_f*G_r*V_e + \alpha_f*\alpha_r*G_c*G_f*I_r + 
\alpha_f*\alpha_r*G_e*G_r*I_f - \alpha_f*G_c*G_e*G_r*V_c - \alpha_r*G_c*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
$V_2 = (G_b*G_c*I_f + G_b*G_r*I_f - G_c*G_f*I_r + G_c*G_r*I_f - \alpha_f*G_b*G_c*I_r + G_b*G_c*G_f*V_b + G_b*G_c*G_e*V_e + G_c*G_e*G_f*V_e + G_b*G_f*G_r*V_b + G_b*G_e*G_r*V_e + G_c*G_f*G_r*V_c + G_c*G_e*G_r*V_e + G_e*G_f*G_r*V_e - \alpha_f*\alpha_r*G_b*G_r*I_f + \alpha_f*\alpha_r*G_c*G_f*I_r - \alpha_f*\alpha_r*G_c*G_r*I_f - \alpha_f*G_b*G_c*G_r*V_b + \alpha_f*G_b*G_c*G_r*V_c - \alpha_f*G_c*G_e*G_r*V_e - \alpha_r*G_c*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
$V_1 = (G_b*G_e*I_r + G_b*G_f*I_r + G_e*G_f*I_r - G_e*G_r*I_f - \alpha_r*G_b*G_e*I_f + G_b*G_c*G_e*V_c + G_b*G_c*G_f*V_c + G_c*G_e*G_f*V_c + G_b*G_e*G_r*V_b + G_b*G_f*G_r*V_b + G_c*G_e*G_r*V_c + G_c*G_f*G_r*V_c + G_e*G_f*G_r*V_e - \alpha_f*\alpha_r*G_b*G_f*I_r - \alpha_f*\alpha_r*G_e*G_f*I_r + \alpha_f*\alpha_r*G_e*G_r*I_f - \alpha_r*G_b*G_e*G_f*V_b - \alpha_f*G_c*G_e*G_r*V_c - \alpha_r*G_c*G_e*G_f*V_c + \alpha_r*G_b*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
\begin{figure}[h]
    \caption{Ebers Moll Linear Model}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LinearEbersMoll.png}
    \label{fig:LinearEbersMoll}
\end{figure}
From these equations the current at each of the nodes can be given in terms of the correct node voltages and constants. In order to implement this model with these equations four methods are used within the BJT:
\begin{itemize}
    \item Set OP
    \item Get Collector Coefficient (double Node)
    \item Get Emitter Coefficient (double Node)
    \item Get Constant Coefficients (double Node)
\end{itemize}
Set OP has to be called at the beginning of each iteration within the Transient Solver algorithm and sets the operating points of the diodes. In order to do this it has to subtract the voltage across the connection resistor (calculated using the current through the nodes) to find the voltage across the diodes. The diodes are set in the same way as previously described in the diode section. The denominator D in the equations above is then also calculated so it does not have to be re-calculated each time by each of the coefficient functions. The coefficient functions each provide the dependence of current on their respective node voltages for the node given by the parameter. When the coefficients are calculated they are saved as this speeds up calculating the current later on. The equations in these methods are sped up by calculating the multiplication of constants in the diode constructor and storing them, such as $G_b*G_e*G_c$ as well as factorising the equation where possible as can be seen in figure \ref{fig:BJTCollector}.    
\begin{figure}[h]
    \caption{BJT Collector Coefficient Generator}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTCollector.png}
    \label{fig:BJTCollector}
\end{figure}
After voltages have been calculated in a circuit the BJT is also required to have a method to calculate the current passing through it. Unlike the other components the BJT GetCurrent method return a vector double as opposed to a double. The fist value in the vector represents the current going into the collector, the second the base, and the third the emitter. When the coefficients for each node were calculated earlier when calculating voltages they were stored in three vectors. This means that using the voltages the currents can quickly be calculated, this is shown in figure \ref{fig:BJTCurrent}. 
\begin{figure}[h]
    \caption{BJT Current Generator}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTCurrent.png}
    \label{fig:BJTCurrent}
\end{figure}
The BJT used within our simulation was the 2N2222, which has values of $I_S = 10^{-14}$, $R_b = 10$, $R_c = 0.3$, $R_e - 0.2$, $\beta_r = 3$ and $\beta_f = 200$.
\bigbreak
See source code: Component.hpp (BJT) for implementation
\newpage
\section{Analysis Algorithms}\label{sec:AnalysisAlgorithms}
\subsection{Parser}\label{ssec:Parser}
The role of Parser.hpp is to read an input text file (compatible with a SPICE netlist)\cite{SpiceSourceFiles} that defines the circuit and the simulation and convert it to a suitable circuit object.\medbreak
In the input file each component has a unique designator letter \bigbreak
\begin{figure}[h]
    \caption{Components input format}
    \centering
    \includegraphics[width=1\textwidth]{images/components_input_format.PNG}
    \label{fig:ComponentsInputFormat}
\end{figure}
Note that our design was made capable of dealing with some additional components such as

\begin{center}
\begin{tabular}{ |c|c|c|c|c|}
\hline
 Designator letter & Component & Node order & Value  \\ 
 \hline
 G & Voltage Controlled Current Source & In,out,control\_Voltage+,control\_Voltage- & gain \\  
 \hline
 E & Voltage Controlled Voltage Source & +,-,control\_Voltage+,control\_Voltage- & gain\\ 
 
 \hline
\end{tabular}
\end{center}




Firstly Parser.hpp constructs an empty Circuit instance, it then peeks the first character of each line of the input file.
\begin{itemize}
\item If the first character is a \textit{designator letter}, it constructs a new Component in the heap with the aid of read\_value and read\_node\_number functions, it then updates the Circuit instance by using the Circuit::add\_component function.
\item If the first string of the line is \textit{.tran} it then proceeds to run a Transient analysis of the Circuit 
\item If the first character is a \textit{*} it ignores the line because it is a comment
\item If the first string of the line is \textit{.end} it closes the input file
\end{itemize}

\begin{figure}[h]
    \caption{Parser algorithm}
    \centering
    \includegraphics[width=0.7\textwidth]{images/Parser_flowchart.PNG}
    \label{fig:ParserFlowchart}
\end{figure}

\bigbreak
See source code: Parser.hpp for implementation

\subsection{KCL Solver}\label{KCLsolver}
The role of KCL\_Solver is to solve for the Circuit voltages at a given instance in time by constructing a conductance matrix. The matrix requires that all components have a linear relationship between current and voltage as it uses linear algebra to solve the circuit. At the start of our project a rapid prototype of the algorithm was made that functioned correctly but wasn't designed to be as efficient as possible. This was necessary as it allowed other sections of the program to operate that needed the algorithm to be worked on without having to wait for a final version. The KCL Solver algorithm needs to be particularly fast as it may be run by the Transient Solver algorithm many times each time step, meaning it is the biggest bottle neck to speed.
\subsubsection{Rapid Prototype Model}
This model was designed to be quick and simple to allow us to add more components. However, it has many areas where it is repeating calculations resulting in slower speeds.\\ The algorithm takes a circuit object by reference and modifies the voltages inside of the object. Firstly it iterates through each of the nodes and at each node it iterates through each component objects. At each component the algorithm stores the coefficients describing the current coming from that component depending on the voltages at each node, as well as the constant current coming from the component. These values are added to a vector of doubles where each index represents the corresponding node. For instance a resistor with an anode of node 1 and a cathode of node 2 would add its conductance to the second index of the vector and the negative of its conductance to the third of the vector, if we are looking at the cathode. Once all the components have been iterated through this vector is inserted as a row in a matrix corresponding to that nodes index. This forms the conductance matrix which is used to calculate the voltages as described earlier.\\
In the case of voltage sources however, this gets a little more complicated. Since the current through the voltage source can't be calculated using the voltage across it an iterative technique was used to find the current coming into the voltage source. The function that creates the vector of coefficients would be called on the opposite node of the voltage source, but this time ignoring the connection to the voltage source. This vector of doubles could then be modified by replacing all instances of the opposite node with the current node minus the voltage of the voltage source. Once complete this vector of doubles can be added to the current vector of doubles for the node and the iteration through the components continues. 
\bigbreak
See source code: OLDKCLsolver.hpp for implementation
\newpage
\subsubsection{Final Optimized Model}\label{ssec:optimizedmodel}
The final version of the KCL solver has been designed to be as fast and efficient as possible. Overall, the newly designed algorithm was found to be on average 25\% faster than the prototype function.

\begin{figure}[h]
    \caption{KCL algorithm}
    \centering
    \includegraphics[width=0.6\textwidth]{images/KCL_flowchart.PNG}
    \label{fig:KCLFlowchart}
\end{figure}

\paragraph{Nodal Analysis}
In order to perform a transient simulation we evaluated the node voltages of the circuit at each successive instant in time. This is done by applying KCL at each node in the Circuit and then solve the set of simultaneous equations obtained.\medbreak
To solve the problem computationally we resorted to linear algebra and decided to write the set of simultaneous equations in the following form
\begin{figure}[h]
    \caption{Circuit analysis equations}
    \centering
    \includegraphics[width=5cm]{images/Conductance_Matrix.PNG}
    \label{fig:ConductanceMat}
\end{figure}

where, starting form the left, we have the conductance Matrix, the vector containing the voltages at each node and the vector containing the currents flowing into each node
\newpage
\subparagraph{Linear Components}
For Resistor, Voltage-Controlled-Current-Source and Current source the approach was to insert the defining equation of the given component in the set of linear equations. 
\subparagraph{Non-Linear Components}
For Capacitor, Inductor and Diode we first had to linearize the respective defining equation.
This was done by replacing each component in the circuit by its respective linear companion model (see \cite{LinearCompanionModels}) and use the new linear equations to solve the matrix. By extension, also BJT is handled in this way because we chose to use Ebers-Moll model to implement it.\bigbreak

Note that linear Companion models have been preferred to numerical integration by trapezoidal rule for Capacitor and Inductor because the former method is faster and produces more accurate results.
\subparagraph{Voltage Components}
Since voltage components have infinite conductance a different approach had to be undertaken. Their equation is written in the matrix after all the other components have been dealt with. The row corresponding to the anode of the component is added to the row corresponding to the cathode creating a supernode. Then row corresponding to the anode is replaced with the defining equation of the voltage component.
\begin{figure}[h]
    \caption{Circuit analysis equations containing a voltage source}
    \centering
    \includegraphics[width=5cm]{images/Voltage_source_matrix.PNG}
    \label{fig:VoltCompConductanceMat}
\end{figure}

\paragraph{Constructing The Conductance Matrix}
The general nodal analysis algorithm implies writing a KCL equation for each node of the circuit. KCL performed at node n resulted in row n of the matrix and index n of the vector of currents being modified. A complete set of equations would look like this \bigbreak

\begin{bmatrix}
a_{00} & a_{01} & a_{02} & a_{03}\\
a_{10} & a_{11} & a_{12} & a_{13}\\
a_{20} & a_{21} & a_{22} & a_{23}\\
a_{30} & a_{31} & a_{32} & a_{33}
\end{bmatrix}
\cdot
\begin{bmatrix}
v_{0} \\
v_{1} \\
v_{2} \\
v_{3}
\end{bmatrix}
=
\begin{bmatrix}
i_{0} \\
i_{1} \\
i_{2} \\
i_{3}
\end{bmatrix}

\bigbreak
Since v\verb|_|0 is assumed to be GND, Column 0 and Row 0 are then removed from the set of linear equations. This produces a \textit{reduced set of linear equations}
\bigbreak


\begin{bmatrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{bmatrix}
\cdot
\begin{bmatrix}
v_{1} \\
v_{2} \\
v_{3}
\end{bmatrix}
=
\begin{bmatrix}
i_{1} \\
i_{2} \\
i_{3}
\end{bmatrix}

\bigbreak
This operation, necessary to make the system solvable, makes indexes of the form $a_{0n}$ and $a_{n0}$ invalid. In order to avoid creating a matrix and then resizing it (very slow operation), we decided to instantiate directly a matrix of the right size and adjust the filling to obtain an equivalent result. This implied writing every element at index $a_{nn}$ to index $a_{n-1,n-1}$ and omit the operation if it resulted in an invalid index being written.

\paragraph{Filling The Conductance Matrix}
Each Current component within our model can be thought as a combination of Resistor and Current Source. This means that a Current component can be represented mathematically as some conductances in the conductance Matrix and currents in the vector of currents.\\
The information of where the coefficients should be written is encoded in the \textit{anode} and \textit{cathode} of the component and what should be written is specified by the kind of component.\bigbreak

Firstly, we iterate through the Circuit::vector$<$Component*$>$ to know how the equations need to be set up. We have made the design choice of using \textit{pointers} as opposed to object instances for the following reasons
\begin{itemize}
  \item They allow maximum exploitation of the hierarchical design. Component* can be downcast to a derived Components (e.g. Resistor*,Inductor*...) thus allowing us to use derived classes' methods.
  \item They allow Components to be instantiated in the Heap, thus enabling us to have a single instance of a given Component that each macro-block in our design can refer to. For instance components are constructed by Parser (see \ref{ssec:parser}) and then processed by KCL solver
  \item They avoid copy-constructing objects producing therefore a significant speed increase of our program
\end{itemize}

Note that the following section describes how to insert coefficients in the non reduced matrix. Our code then maps each coefficient to the right position in the reduced matrix\bigbreak
The convention followed is that the current going out of each node must sum up to 0.\\
If the component is a Resistor then we know that its characteristic equation is $Current = \frac{V_{Anode} - V_{Cathode}}{R}$. We look at row Anode and write $\frac{1}{R}$ at $a_{Anode,Anode}$  and write $-\frac{1}{R}$ at $a_{Anode,Cathode}$ . Symmetrically we then look at row Cathode and write $\frac{1}{R}$ at $a_{Cathode,Cathode}$  and write $-\frac{1}{R}$ at $a_{Cathode,Anode}$.\\
If the component is a Current Source then we look a index anode in the current vector and write +Current. We then look at index cathode in the current vector and write -Current.\\
This approach is extended for Current Components. For Diodes \ref{ssec:Diode} and BJTs \ref{ssec:BJT} specific implementation see relative sections.

\subparagraph{Voltage Components}
When encountered, Voltage Components are stored in a vector to be processed after Current Components and BJTs are handled.\bigbreak
If the component is a Voltage Source or an AC Voltage Source then we know its characteristic equation is $V_{anode}-V_{cathode}=V_{src}$. We create a supernode equation by adding row anode to row cahtode and index anode to index cathode in the vector of currents. We then look at row anode and write 1 at $a_{Anode,Anode}$ and write -1 at $a_{Anode,Cathode}$. We also write $V_{src}$ at index anode of the vector of currents.\\ For Voltage Controlled Voltage Sources the principle is extended by adding the additional terms included in the characteristic equation.\bigbreak
We are well aware of the fact that if two Voltage Components anodes are connected together this might cause problems. In order to solve this issue we made sure that if this is the case than the anode and cathode of a voltage source are switched and $V_{src}$ is multiplied by -1.

\paragraph{Dense vs Sparse Matrix}
As the number of nodes of a given circuit varies then it makes sense, in order to improve performance, to use different different kinds of Matrices optimized for the problem we are dealing with. \\
The Eigen library provides us with two different categories :
\subparagraph{Dense Matrix} Designed to deal efficiently with small-medium matrices where most coefficient are different from zero.
\subparagraph{Sparse Matrix} Designed to deal with very large matrices where only a few coefficients are different from zero. In such cases, memory consumption can be reduced and performance increased by using a specialized representation storing only the nonzero coefficients.\bigbreak
Testing revealed that the sparse matrix was faster than using dense matrix for circuits of any order and so the sparse matrix implementation was used in the final program. Eigen has several different algorithms for solving a sparse matrix and the one we chose was SparesLU. We did not find this to be the fastest algorithm but it did give the most stable results in terms of accuracy, with other algorithms often not converging when used for diodes due to high inaccuracies. \\
Dense matrix also has different solving algorithm and we found that using the matrix.inverse() method yielded the fastest and most accurate results in our testing. 
\bigbreak
See source code: KCLsolver.hpp for Dense implementation \\
See source code: sparseKCLsolver.hpp for Sparse implementation
\newpage

\subsection{Transient Solver}\label{ssec:TransientSolver}
When non-linear components such as BJT's and diodes are present in a circuit solving the circuit using linear algebra is no-longer possible. Due to the complexity of diode and BJT equations the method used to solve these non-linear circuits is the iterative Newton-Raphson method. The equation that describes the iterative method is:
\bigbreak $x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$\bigbreak
By repeating this iteration $x_n$ may converge such that $f(x_n) = 0$
Originally we considered that due to the presence of many node voltages in a circuit and a diode current being dependent on two of those voltages a multi-variable method would have to be used. We researched how to modify the above equation for multi variable equations and found a lecture\cite{mulitvariableNR} describing the use of a Jacobian matrix. We tried implementing this method by giving each current component a function that returns a vector storing the partial derivatives of its current with respect to each current. However, we did not like how much computation this method required and found after more research\cite{NewtonRaphson} that we could describe the current through the diode as a function of the voltage across it which is only one variable\cite{LinearCompanionModels}. So the use of multi-variable iteration was not needed. In order to solve the diode using Newton-Raphson we need to form an KCL equation that is equal to 0. Doing KCL at the diodes anode we have the equation:
\bigbreak $I_d - I_{in} = 0$\bigbreak
Where $I_in$ is the current entering the diode and $I_d$ is the current due to the diode current equation. Combining this with Newton-Raphson gives:
\bigbreak $x_{n+1} = x_n - \frac{I_d - I_{in}}{\frac{d I_d}{d V_d}}$\bigbreak
The Newton Raphson method the function each iteration as a linear function and so a diode is going to need to be modeled as a resistor and current source in parallel as any linear voltage current relationship can be modelled as this, (apart from those with an infinite gradient). If we consider a diode as a current source in parallel with a resistor we can again do KCL at its anode to form the equation. 
\bigbreak $V_d*G_l + I_l - I_{in} = 0$ Where $G_l$ and $I_l$ are the conductor and current source values.\bigbreak
We want to find a value of $G_l$ and $I_l$ such that if we solve the circuit using the KCL solver algorithm the voltage across the diode will be $V_{n+1}$
\bigbreak
Thus if we rearrange the Newton-Raphson equation we have:\bigbreak
$x_{n+1}*\frac{d I_d}{d V_d} = x_n*\frac{d I_d}{d V_d} - I_d + I_{in}$\bigbreak
From this we can see that if we make $G_l = \frac{d I_d}{d V_d}$ and $I_l = I_d - x_n*\frac{d I_d}{d V_d}$ when the equation is solved the voltage across the diode will be $V_{n+1}$\bigbreak
If we keep repeating this method of setting the value of G and I for each diode and then solving the circuit and then resetting the values the circuit should converge to the correct values. To complete the iterations though we need some way of telling when the circuit has converged to an acceptable accuracy. 
Within Spice two parameters are used to measure this convergence.
\begin{itemize}
    \item RELTOL
    \item ABSTOL
\end{itemize}
Spice combines these two parameters within the inequality $|v_{n+1}-x_n| < RELTOL*|x_n| + ABSTOL$.\\
RELTOL measures the relative change in the voltage and ABSTOL is present as near 0V $RELTOL*|x_n|$ may become too small. Each iteration of our algorithm each of the node voltages is compared using this inequality to the previous voltage and if all the inequalities return true the algorithm finishes. A maximum number of iterations is set so that the program can't get stuck in an infinite loop. Within our program the max iterations was set to 1000 as we found that a correct circuit usually has a max iterations of a few hundred on the first time step and so this provides room for that occur. We set RELTOL and ABSTOL to values of $10^{-3}$ and $10^{-12}$ respectively. This provided a trade off between accuracy and speed of our program. If higher accuracy is needed RELTOL should be decreased. 
\bigbreak
In order to implement this algorithm the flow diagram shown in figure \ref{fig:transient} is used. The entire algorithm is contained within one function called TransientSolver. This function takes a circuit object by reference and modifies its voltages to the correct voltages given components in the circuit or exits the program if the maximum iterations is reached. This means that the starting guess for the voltage is the voltages from the previous time instance meaning that they are very close to the new voltages. This results in very few iterations normally being needed. Only the first iteration with starting guesses of 0V takes many iterations under normal use. \\

The algorithm runs within a while loop, starting by looping through all the components and setting the linear current and conductance of all diodes and BJT's. As BJT's are simply modelled as containing two diodes they converge in the same manner as diodes do. The algorithm then saves the circuit voltages in a vector before running the KCL solver algorithm on the circuit. After this it compares the old voltages with new and breaks the while loop if complete.  

\begin{figure}[h]
    \caption{Transient Solver Algorithm}
    \centering
    \includegraphics[width=0.5\textwidth]{images/TransientSolverAlgorithm.png}
    \label{fig:transient}
\end{figure}
\bigbreak
See source code: TransientSolver.hpp for implementation 
\newpage

\subsection{DC Operating Point Analysis}\label{ssec:DCanalysis}
The DC operating point analysis is required to find the starting node voltages for the transient analysis. It is very similar to the transient analysis and uses most of the same code base. The difference is that it only looks at a single point in time as well as assuming all capacitors to be open circuits, inductors to short circuits and ac sources to be at their dc bias point. In order to implement this the linear conductance and current of the capacitors are all left at their default value of 0, essentially making them open circuits. The same is used for the ac sources with their default values being their dc bias.\\Unfortunatly inductors are a little more complicated to implement as short circuits. In order to do this the same method as used in the final KCL solver for treating voltage sources was used as a short circuit can be thought of as a 0V voltage source. To allow for this a boolean parameter was added to the KCL solver function with a default values of false. When this is set to true all inductors are treated in this way, forming super nodes.\\
With this code added to the KCL Solver the OP analysis function simply has to check if the circuit is linear or not and run the KCL solver or the transient solver algorithm respectively. 
\bigbreak
See source code: OPAnalysis.hpp for implementation 
\newpage

\subsection{Calculate Currents}
When running a transient or dc analysis one of the outputs of the simulation is the current passing through each component. For most components this is fairly simple as the voltage across the components can be used to calculate the current passing through them. This is the purpose of the current\_component base class as it allows for a pure virtual get current function that can be implemented by each current component. This function takes the vector of voltages and modifies the current variable within the current\_component class.\\Voltage Components are more complicated as their current can not be calculated from the voltage across them. In order to calculate their current the current through all non voltage components is first calculated and then the current coming into each voltage component can be calculated using a recursive algorithm. This is why the node struct was made as it allows for all the components connected to each node to be easily found which is necessary for this algorithm as opposed to finding all the components connected to a respective node each time step. During OP analysis inductors are treated in the exact same way as voltage sources, just with a 0V value and during transient analysis they are treated as current components.\\ 
\begin{figure}[h]%
    \centering
    \subfloat[Calculate Current Algorithm]{{\includegraphics[width=5.5cm]{images/CalculateCurrent.png} }}%
    \qquad
    \subfloat[Calculate Voltage Component Algorithm]{{\includegraphics[width=5.5cm]{images/CalculateVoltageCurrent.png} }}%
    \caption{Calculate current models}%
    \label{fig:CalculateCurrent}%
\end{figure}

To calculate current within a circuit first the voltages must be found and then the calculate currents method can be called, passing the circuit object by reference. An optional boolean parameter with a default value of false is also present that tells the algorithm how to treat inductors. The flow diagram for the Calculate Current method is shown in figure \ref{fig:CalculateCurrent}. The calculate voltage component current method flow diagram is shown in figure \ref{fig:CalculateCurrent}, during OP analysis the same method is used for inductors. The node parameter is present in the algorithm to ensure that if two voltage sources have their anodes connected the algorithm wont get stuck in a loop. 
\bigbreak
See source code: AnalysisOutput.hpp for implementation

\newpage

\subsection{Transient Analysis}\label{ssec:TransientAnalysis}
The transient Analysis function controls the overall simulation elements, it is responsible for updating the values of linear components at each time instance and writing the node voltages and component currents to output files once KCL or transient solver has run. The transient analysis inputs are: 
\begin{itemize}
    \item The Circuit.obj generated by parser
    \item The number of time steps (calculated by taking Time-period/Length of Time step) 
    \item The time period / end time from 0 
\end{itemize}
The function follows this design:

\begin{figure}[H]
\centering
\includegraphics[width =0.5\textwidth]{ images/TranAna.PNG}
\label{fig:TranAna} 
\caption{Transient Analysis algorithm flow diagram}
\end{figure}
Linear and non linear components follow different paths as they use different methods of calculation. I.e non-linear components converge
\smallbreak
The set conductance function simply loops though each component in the Circuit and sets their conductance if they are a energy storage device based on the parameter of delta time, see inductor and capacitor models for further detail.\\
The update node voltages function goes through and updates the value of variable voltage sources such as the AC Voltage source at the current time. It then runs the Transient solver if diodes or bjts are present and the KCL solver if not. 
After this the circuit vector of nodes has been updated to the new values for that time instance\\
The calculate current function is then called which calculates the current through each component and then stores that current in the current parameter of voltage components, current components or BJTs.   \\
The new node voltages and currents are all then outputted to their respective files by the nodevoltagetofile()  function which inputs the values in CSV format to two txt files.\\
Finally the transient analysis assesses whether the simulation has reach its specified end time, continuing the process with the next time value or ending simulation depending on this evaluation.\\ 
Our original code used a constant time step through out the simulation. Spice however, uses a dynamic time step, decreasing it when the voltage time gradient is high, resulting in more accurate results for energy storage components. In testing a simple version of this algorithm was implemented to see the accuracy possible with such an algorithm. The time step was adjusted using the following formula which was generated through trial and error. \bigbreak
$timestep = (1/grad) * max\_timestep * 10$\bigbreak
Where the max\_timestep is the timestep inputted by the user and grad is the biggest voltage time gradient out of all the nodes. The time step was also prevented from going lower than $10^{-5}$ to prevent it becoming too small. This did result in lower error but due to a lack of time to test this implementation as thoroughly as we would've liked it was left out of the final code. 

\begin{figure}[h]%
    \centering
    \subfloat[Component current output files]{{\includegraphics[width=5.5cm]{images/CurrentOut.PNG} }}%
    \qquad
    \subfloat[Node voltage output files]{{\includegraphics[width=5.5cm]{images/Vout.PNG} }}%
    \caption{Output file formats}%
    \label{fig:CalculateCurrent}%
\end{figure}



\bigbreak
See source code: TransientAnalysis.hpp and AnalysisOutput.hpp for implementation


\newpage
\section{Testing and Evaluation}
\subsection{Linear Components}
In order to test our KCL solver algorithm many different test cases had to be used to ensure their were no special cases that didn't work which allowed us to remove a few small bugs. In order to demonstrate the ability of the algorithm to solve complex circuits the circuit shown in figure \ref{fig:LinearTest} was used. The voltages that our algorithm computed where slightly different to the the values calculated by spice and it is not completely clear why. It could be a combination of both floating point errors as well as errors introduced by the Eigen library with the library having to provide a compromise between speed and accuracy. A few values from our circuit and spice are shown in the table along with relative accuracy's in percent. 
\begin{center}
\begin{tabular}{ ||c|| c |c | c | c | c | c | c | c | c | c ||}
 \hline
  & Node 1 & Node 2 & Node 3\\  
  \hline
 Spice & 8 & -27.833 & -24.833\\   
 Simulation & 7.99 & -27.843 & -24.843\\
 Error & 0.125 & 0.035 & 0.04\\ 
 \hline
\end{tabular}
\end{center}
\begin{figure}[h]
    \caption{Linear Test}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LinearTest.png}
    \label{fig:LinearTest}
\end{figure}

\subsection{Voltage controlled sources}
To ensure functionality of the extra Voltage Controlled components within our implementation two simple tests were run.
\subsubsection{Voltage Controlled Voltage Source}
  In order to demonstrate the ability of the algorithm to solve circuits with Voltage Controlled Voltage Source the circuit shown in figure \ref{fig:VCCStest} was used.
\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|}
\hline
 & Node 1 & Node 2 & Node 3 & Node 4 & Current\\ 
 \hline
 Spice & 4 & 4.66667 & 8 & -1.33333 & -0.00444444 \\  
 \hline
 Simulation & 4 & 4.66667 & 8 & -1.33333 & -0.00444444 \\ 
 \hline
 Error & 0 & 0 & 0 & 0 & 0\\
 \hline
\end{tabular}
\end{center}

\begin{figure}[h]
    \caption{VCVS test}
    \centering
    \includegraphics[width=0.5\textwidth]{images/VCVS_test.PNG}
    \label{fig:VCCStest}
\end{figure}

\subsubsection{Voltage Controlled Current Source}
In order to demonstrate the ability of the algorithm to solve circuits with Voltage Controlled Current Source the circuit shown in figure \ref{fig:VCCStest} was used.

\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|}
\hline
 & Node 1 & Node 2 & Node 3 & Node 4 & current\\ 
 \hline
 Spice & 4 & -0.444444 & -22.6667 & 8.88889 & -0.000666667\\  
 \hline
 Simulation & 4 & -0.444444 & -22.6667 & 8.88889 & -0.000666667 \\ 
 \hline
 Error & 0 & 0 & 0 & 0 & 0\\
 \hline
\end{tabular}
\end{center}

\begin{figure}[h]
    \caption{VCCS test}
    \centering
    \includegraphics[width=0.5\textwidth]{images/VCCS_test.PNG}
    \label{fig:VCCStest}
\end{figure}

\newpage
\subsection{Testing Diodes}
\subsubsection{Test 1}
The accuracy of circuits containing diodes is dependent on the error that we set with the RELTOL and ABSTOL parameters within our program. The values of RELTOL that we used was $10^{-3}$ as so our relative accuracy should be in the region of $0.1\%$. This accuracy is not possible at values very close to 0V and the ABSTOL parameter sets a limit on the maximum finite accuracy of the simulation. When testing our diodes we continued to aim for an average relative accuracy of $0.5\%$ as a bench mark. We found that in order to achieve this the presence of connection resistances in the diode model were necessary especially when other low resistances are present in the circuit. \\
A simple test of the diode in series with a resistor as shown in figure \ref{fig:DiodeTest1} demonstrates the diode functioning correctly. This table shows the spice output compared to our simulator output. As can be seen our accuracy is far within the margin set. The diode also behaves as expected when connected to ground, voltage sources and current sources with similar accuracy.  
\begin{center}
\begin{tabular}{ ||c| c ||c ||}
\hline
 Spice & Simulator & Percentage Error \\ 
 \hline
 2.86753 & 2.86746 & 0.0024 \\  
 2.13247 & 2.13254 & 0.0034 \\   
 \hline
\end{tabular}
\end{center}
The current was also tested and the relative errors are shown compared to spice in the table.
\begin{center}
\begin{tabular}{ ||c| c ||c ||}
\hline
 Spice & Simulator & Percentage Error \\ 
 \hline
 21.3247 & 21.3254 & 0.0033 \\  
 \hline
\end{tabular}
\end{center}
\begin{figure}[h]
    \caption{Diode Test 1}
    \centering
    \includegraphics[width=0.5\textwidth]{images/DiodeTest1.png}
    \label{fig:DiodeTest1}
\end{figure}
\newpage
\subsubsection{Test 2}
We also tested our diode in full wave rectifier arrangement to demonstrate its accuracy in more complex circuits. The circuit used is the one shown in figure \ref{fig:DiodeTest2}. Testing was more complicated as we needed to compare with the spice output at different time steps. As spice doesn't use constant time steps unlike our algorithm we cannot simply compare the voltage at each time step. In order to measure the accuracy we created a python script that interpolates the data from spice to give a voltage at each time step. In order to do this we assumed each of the voltage changes in the spice output to be linear. This can then be compared to our output and taking the average error across all the time steps. As our value of ABSTOL was $10^{-12}$ any value of voltage lower than this didn't have its error compared. We found that the average error for the voltage across the resistor across all time steps was 0.043\% and the maximum error was 1.2\%. The graphical output of our rectifier can be seen in figure \ref{fig:FullWaveRec} and is as expected from a full wave rectifier. Our analysis was run over 5 seconds with 0.01 second time steps. 
\begin{figure}[h]
    \caption{Diode Test 2}
    \centering
    \includegraphics[width=0.5\textwidth]{images/DiodeTest2.png}
    \label{fig:DiodeTest2}
\end{figure}
\begin{figure}[h]
    \caption{Full Waver Rectifier Output}
    \centering
    \includegraphics[width=0.4\textwidth]{images/FullWaveRec.png}
    \label{fig:FullWaveRec}
\end{figure}
\newpage
\subsection{Testing BJT}
\subsubsection{Test 1}
To test the BJT was working we used the circuit shown in figure \ref{fig:BJTTest1} was used. The table below shows the voltage from the spice simulation and our simulation as well as the relative error. The error is greater than that found in the diode but still within an acceptable margin. Are model unlike spice negates the use of a Ro resistor between the collector and emitter junction. When testing it was found that if a 50K resistor is added between these junctions the voltage output is closer to that predicted by spice. 
\begin{center}
\begin{tabular}{ ||c| c ||c ||}
\hline
 Spice & Simulator & Percentage Error \\ 
 \hline
 4.98968 & 4.98926 & 0.0084 \\  
 4.29682 & 4.29495 & 0.043 \\   
 \hline
\end{tabular}
\end{center}
The currents were also compared to the spice model and the outputs in mA and relative error in percent are shown in the table below. As can be seen the errors are all very low except the base current. This is to be expected however, as the finite error on the base will be a much bigger percentage of it as the base current is so much smaller than the other currents. This does show a limitation though with our BJT model. 
\begin{center}
\begin{tabular}{ ||c| c |c |c | c| c| c| c ||}
\hline
  & QC & Qb & Qe & R1 & R2 & V & R3 \\ 
  \hline
 Spice & 4.276 & 2.064e-02 & -4.297 & 5.010 & 4.989 & -9.287 & -4.297\\
 Sim & 4.273& 2.147e-02& -4.294& 5.011& 4.989& -9.284& -4.295  \\
 Error &  0.07& 4 & 0.07 & 0.02 & 0.00 & 0.03 & 0.05  \\   
 \hline
\end{tabular}
\end{center}
\begin{figure}[h]
    \caption{BJT Test}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTTest1.png}
    \label{fig:BJTTest1}
\end{figure}
\newpage
\subsubsection{Test 2}
We also tested the BJT in a transient analysis with a CE amplifier circuit shown in figure \ref{fig:BJTTest2}. As is talked about in the capacitor testing section interpolation had to be used on the spice outputs to compare them to our outputs. The waveform at the output was as expected as can be seen in figure \ref{fig:BJTOutput2} however, the average error of the simulation was 1.6\% when measured against the spice output voltage. This is similar to other circuits tested with capacitors and so demonstrates that the BJT model is functional in this arrangement. The BJT as expected has a negative gain as the output waveform shows negative scaling compared to the sin wave that was inputted. 
\begin{figure}[h]
    \caption{BJT Test 2}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTTest2.png}
    \label{fig:BJTTest2}
\end{figure}
\begin{figure}[h]
    \caption{BJT Test 2 Output}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTOutput2.png}
    \label{fig:BJTOutput2}
\end{figure}
\newpage
\subsection{Testing Capacitor Model}
When testing energy storage devices it was expected that there would be more error than found when testing other components due to the effects of integration error. We tested a capacitor connected to an ac source as shown in figure \ref{fig:CapTest}. This test resulted in an average error measured against the spice interpolated data of 3\%. This seemed fairly high and was likely due to the fact that errors at high gradients near the start of the capacitor charging can be very inaccurate, up to 50\% for small voltages. Spice combats this by dynamically adjusting its time step so that when gradients are steep the time step is smaller. In order to reduce our error we decided to implement a simple version of this algorithm that has been used for the testing shown here and is described in the Transient Analysis section. This however was not included in the final code as it has not be tested enough to be completely stable. When using this algorithm the error was reduced to an average of 1.5\% whilst only increasing the number of time steps by about 20\%. Capacitors were also tested in similar arrangements connected to ground and each of the different component types as well as in parallel with components to check no bugs were present in special cases. As the current in the capacitor is calculated directly from the voltage across it we found that the errors for current were the same as for voltage which was true for all our energy storage tests.
\begin{figure}[h]%
    \centering
    \subfloat[Capacitor Circuit]{{\includegraphics[width=5.5cm]{images/CapacitorTest1.png} }}%
    \qquad
    \subfloat[Capacitor Waveform]{{\includegraphics[width=5.5cm]{images/CapWaveform.png} }}%
    \caption{Capacitor Test}%
    \label{fig:CapTest}%
\end{figure}
\newpage
\subsection{Testing Inductor Model}
When testing inductors in the circuit shown in figure \ref{fig:InducTest} we found a slightly higher error than the capacitor with an average of 4.5\% across the analysis with a maximum error of 60\%. When we switched to the dynamic time steps as with the capacitors we saw an error of 1.5\% average and 40\% maximum in measuring the voltage across the inductor. As with the capacitor this relatively high error suggests that a better algorithm for adjusting the time steps is needed to match the outputs from spice. Given the fact that these components are dependent on integrals an error of 1.5\% is not huge and in many circuits better than the error on the values of the components in real world tests.
\begin{figure}[h]%
    \centering
    \subfloat[Inductor Circuit]{{\includegraphics[width=5.5cm]{images/InductorTest1.png} }}%
    \qquad
    \subfloat[Inductor Waveform]{{\includegraphics[width=5.5cm]{images/InducWaveform.png} }}%
    \caption{Inductor Test}%
    \label{fig:InducTest}%
\end{figure}
\newpage
\subsection{Energy Storage Testing}
To demonstrate the functionality of an LC circuit the circuit shown in figure \ref{fig:LCCircuit1} was used. A frequency of 30Hz was used for the ac source and spice gave the waveform shown in figure \ref{fig:LCSpice1}. As can be seen our waveform in figure \ref{fig:LCOutput1} is the same shape as that shown in the spice output. A measure of our accuracy though showed that the average error was 5\%, which is relatively high. This is much higher than our other test but the voltages in this test our very low and so this doesn't represent a terrible absolute error. This circuit is also oscillating at a much higher frequency and so more integration error would be expected as this is a more complex waveform. When voltages less than 0.1mV were ignored the average error decreased to only 0.9\% suggesting that the error for most of the waveform is fairly low and high percentage errors only occur when near 0V. 
\begin{figure}[!h]
    \caption{LC Circuit}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LCCircuit1.png}
    \label{fig:LCCircuit1}
\end{figure}
\begin{figure}[!h]
    \caption{Spice LC Output}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LCSpice1.png}
    \label{fig:LCSpice1}
\end{figure}
\begin{figure}[!h]
    \caption{Simulation LC Output}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LCOutput1.png}
    \label{fig:LCOutput1}
\end{figure}
\smallbreak
\newpage
\subsection{Testing Simulator Algorithm Complexity}
In order to evaluate our algorithm it was important to measure its complexity. This is very hard to do analytically due to the size of our algorithm and so this was done by plotting the time it took to solve circuits of different sizes. The effect of running more time steps in a transient analysis is essentially linear as this just means running the analysis more times and so only OP analysis was used to measure the complexity.\\ Firstly circuits with only linear components were used and so to test this a program was written that would generate a potential divider of n nodes and test how long it took to solve the circuit 100 times. The solution was calculated 100 times to try and average out variation in run time whilst keeping the total run time for many node circuits reasonable. The output of the circuit was not printed to files as this would effect the time and is not what we are trying to measure. The time for the circuit to be passed was also not measured as this is not a part of the algorithm actually used to solve the circuit.\\ Firstly we measure the time taken to solve using the old dense matrix method. This resulted in the graph in figure \ref{fig:DenseTest}, all times in the testing are measured in ms. In order to evaluate the complexity of our graphs the log of time and nods was also plotted, in this case in figure \ref{fig:DenseTest}. The log plot in this case is clearly not completely linear suggesting the complexity may not be completely polynomial. However, in this range the log graph can be approximated as linear and has an average gradient of 2.3. This suggest a complexity between cubic and quadratic.\\ The same measurement was taken using the sparse matrix method shown in figure \ref{fig:SparseTest}. This resulted in a much faster simulation with the log plot now having a gradient of 1.3, suggesting a complexity of roughly linear within this region. This is far better than the dense matrix time and so is the reason why sparse matrices were used in the final project. \\
\begin{figure}[h]%
    \centering
    \subfloat[Time Plot]{{\includegraphics[width=5.5cm]{images/TimeDense.png} }}%
    \qquad
    \subfloat[Log Plot]{{\includegraphics[width=5.5cm]{images/LogDense.png} }}%
    \caption{Dense Matrix Test}%
    \label{fig:DenseTest}%
\end{figure}
\begin{figure}[h]%
    \centering
    \subfloat[Sparse Time Plot]{{\includegraphics[width=5.5cm]{images/TimeSparce.png} }}%
    \qquad
    \subfloat[Sparse Log Plot]{{\includegraphics[width=5.5cm]{images/LogSparce.png} }}%
    \caption{Sparse Matrix Test}%
    \label{fig:SparseTest}%
\end{figure}
The time taken to solve an nth order diode circuit was also measured, in this case n diodes were placed in series with a high enough voltage to put them all in forward bias. The time taken to simulate vs the number of nodes is shown in figure \ref{fig:IterativeTest}. The log plot has the same gradient as before of 1.3 which suggests that the iterative algorithm doesn't change the order of the complexity. This means that the iterative algorithm has been implemented in an efficient manner.
\begin{figure}[h]%
    \centering
    \subfloat[Iterative Time Plot]{{\includegraphics[width=5.5cm]{images/TimeIterative.png} }}%
    \qquad
    \subfloat[Iterative Log Plot]{{\includegraphics[width=5.5cm]{images/LogIterative.png} }}%
    \caption{Iterative Test}%
    \label{fig:IterativeTest}%
\end{figure}
\subsubsection{Energy Usage}
Trying to measure the energy consumption of our program is fairly difficult, especially as this is very dependent on device and conditions. The energy usage of the program should be dependent on the time taken to run it, so an in depth analysis on this has not been done as time for an nth order circuit has already been measured. We did measure the CPU usage of running a simple potential divider with two resistors on a loop though. When running OP analysis on this circuit continuously we found that the CPU usage increased by 11 percent. The CPU being used is a Ryzen 5 2500U which has a maximum wattage of 25 watts. This means that an estimate for the energy consumption could be 2.5 watts, but this measurement is very crude. 
\newpage
\section{Final Evaluation}
\subsection{Technical Problems}
\subparagraph{Parse the netlist file using reduced SPICE format}
Within our design this point is addressed by two different sections
\begin{itemize}
    \item Qt application \ref{ssec:GUIandmain}
    \item Parser algorithm \ref{ssec:Parser}
\end{itemize}
The Qt application aim is to provide an intuitive and user-friendly interface to operate our program. It can select an input file that will then be processed by the Parser algorithm.\\
The Parser macro-block aim is to translate the input file (compatible with a SPICE netlist) into objects usable by our program.\\
\subparagraph{Set up the simulation }
The kind of simulation required is specified in the input file and run by Parser.\\
We support two different kinds of simulation
\begin{itemize}
    \item Transient Analysis \ref{ssec:TransientAnalysis}
    \item DC Bias Point Analysis \ref{ssec:DCanalysis}
\end{itemize}
DC Bias point analysis treats Capacitors as open circuits and Inductors as short circuit\\
Transient Analysis is used to see how the circuit voltages change with time. It starts from initial conditions set by the DC Bias point analysis.
\subparagraph{Construct and solve the conductance matrix and Process voltage sources}
The optimized KCL solver algorithm \ref{ssec:optimizedmodel} deals with setting and solving the system of equations to find the voltages at each node in the circuit.
\subparagraph{Write the output}
The transient Analysis and DC Bias Point analysis simulations write the output both of voltages and currents in a suitable format in two separate files. Then the Qt application deals with the display of the data using an interactive graph.
\subparagraph{ Add support for non-linear components (advanced)}
Both Diodes \ref{ssec:Diode} and BJTs \ref{ssec:BJT} were implemented within our design. We used the iterative Newton–Raphson method to find solutions for such components.\bigbreak


\newpage

\subsection{Analysis and Efficiency }
At the start of our project we set an aim to be able to simulate complex circuits to within 1\% error when compared to spice. Throughout our testing we found this to often be the case with tests of BJTs and diodes often resulting in errors of less than 0.1\% next to spice. Our conductance matrix calculations also provides error well within this margin. The area in which we found greater errors was when measuring circuits with energy storage devices. Due to the nature of these devices higher errors are expected due to the inherent error in numerical integration, but the errors whilst not having a visible effect on our output waveform were higher than expected. In order to improve this in the future we would invest more time into creating a better algorithm for dynamically changing the time step to reduce integration errors as well as trying different integration techniques for different circuits. \\The other area in which we would try and make improvement is the model of our BJT and our diode. We would add a parasitic capacitance to the diode and BJT as well as a Ro value to the BJT. The Ro value in particular would have a big effect in improving the accuracy of our model when compared to the output given by Spice. \\In terms of measuring the efficiency of our design, when using the sparse matrix method we found that the circuit solver has a near linear complexity within the range we tested. This was up to a 2000 node circuit which is well within the range that our simulator is best designed for as our emphasis is not on circuits with BJTs and MOSFETs, thus circuits with higher number of components than this are unlikely to be needed to be simulated. In the worst case circuits our complexity would be expected to of course be much worse and if each node was connected to each other node it could easily be exponential. We also found that our iterative algorithm didn't change the complexity of the relationship between order of the circuit and time to simulate suggesting that this algorithm was implemented in an efficient manner. 
\newpage
\subsection{Software Requirement Specification Evaluation}

\textbf{Functional Requirements}

\medbreak

\textbf{1. Give Node Voltages of a complete circuit within 1 percent of Spice}
\newline
This point was addressed in our testing and evaluation of accuracy and efficiency, the criterion was met in most conditions with intended accuracy. Voltages were outputted in a output\verb|_|voltage.txt
\smallbreak
\textbf{2. Evaluate Current flowing through each component within 1 percent of Spice}
\newline
This point was addressed in our testing and evaluation of accuracy and efficiency, the criterion was met in most conditions with intended accuracy.Currents were outputted in a output\verb|_|current.txt
\smallbreak
\textbf{3. Perform analysis for passive, energy storage devices , diodes and transistors.}
\newline
We saw through our implementation of components and the component write up section the components implemented and the models used to produce them.
\smallbreak
\textbf{4. Take input from a reduced spice netlist file.}
\newline
We saw from our video presentation and GUI write up that a txt containing any netlist file would be parsed and any analysis described was performed. The UI made this function especially easy.
\smallbreak
\textbf{5. Output analysis to an output file.}
\newline
We saw from our transient analysis function that two output files are created containing data to a stipulated accuracy.


\bigbreak

\textbf{Non-Functional Requirements}
\medbreak
\textbf{1. The software must be capable of analyse different kinds of circuits}
\newline
We have seen from the numerous tests performed the ability of our simulator to deal with varying circuits. The video also shows a number of complex circuits operating with accuracy on our system. 

\smallbreak

\textbf{2. The software must be able to perform the analysis in a time efficient way}
\newline
We have seen from our testing on complexity and through our design choices a clear focus on maintaining code and design efficiency that has lead to time efficient design that scales well with an increasing number of nodes. We have also aimed to use optimal code implementation to ensure an efficient solution. 

\bigbreak
The link to our GitHub repository can be found in the bibliography \cite{GitHub}.



\newpage

\bibliographystyle{plain}
\bibliography{bibliography.bib}

\end{document}

