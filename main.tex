\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
\usepackage{amsmath}
\usepackage{subfig}


\title{SLM Circuit Simulator Log}
\author{Sam Taylor, Maximus Wickham , Leonardo Garofalo}
\date{June 2020}

\pagestyle{fancy}
\fancyhf{}
\rhead{SLM Soloutions}
\lhead{SLM Circuit Sim}
\rfoot{Page \thepage}

\graphicspath{ {./images/} }
\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Engineering Design Process}
\flushleft

\subsection{Outline of technical problem to be solved:}
\flushleft

\smallbreak
Write a software package that performs a transient simulation of a circuit, like LTspice. The main elements of such a system are described below:
\newline
\smallbreak
1. Parse the netlist file using reduced SPICE format.
\newline
2. Set up the simulation (Transient Analysis , DC Bias Point Analysis)
\newline
3. Construct and solve the conductance matrix
\newline
4. Process voltage sources
\newline
5. Write the output
\newline
6. Add support for non-linear components (advanced)
\newline
\mediumbreak 

Key Evaluation points:
\newline
1. Accuracy: compare the outputs to pen and paper solutions. 
\newline
2. Efficiency: find how long the simulation takes and, by estimating the power consumption of your computer.

\subsection{Software Requirements Specification:}
\flushleft
\textbf{Outline:} A circuit Simulation that produces transient analysis for circuits containing energy storage devices , diodes and transistors . With reasonable accuracy and speed.

\bigbreak

\textbf{Functional Requirements}

\newline

1. Give Node Voltages of a complete circuit within 1 percent of Spice
\newline
2. Evaluate Current flowing through each component within 1 percent of Spice
\newline
3. Perform analysis for passive, energy storage devices , diodes and transistors.
\newline
4. Take input from a reduced spice netlist file.
\newline
5. Output analysis to an output file.
\newline
6. The software must be capable of dealing with both linear and non-linear devices

\bigbreak

\textbf{Non-Functional Requirements}
\newline
1.The software must be capable of analyse different kinds of circuits
\newline
2. The software must be able to perform the analysis in a fast and efficient way
\newline
3. The software must be capable of performing the analysis consuming the least amount of power possible

\newpage
\subsection{Design Process and Project management}

We chose to use the Scrum framework to manage our collaboration during the project. We initially populated the project backlog with details from the specification and our design overview. Each morning (at varying times) we held a thirty minute scrum to inform each other what we work we would be doing that day. At the end of each day we held a second meeting to discuss what was achieved and what problems we encountered updating the backlog with completed and new tasks.
We also held a bi-weekly sprint meeting where we determined the milestone and objectives of that sprint. We did not use a sprint backlog just kept a single updated backlog. 

\begin{figure}[h]
    \caption{Scrum Framework work pattern}
    \centering
    \includegraphics[width=\textwidth]{images/ScrumFramework.jpg}
    \label{fig:Scrum}
\end{figure}
We also used a timeline to keep general project discipline and keep goals realistic to the final deadline. This was used to ensure we were not implementing more functionality beyond our ability to produce a write up.
\begin{figure}[h]
    \caption{Snapshot of Onenote backlog}
    \centering
    \includegraphics[width=12cm]{images/Backlog.PNG}
    \label{fig:BackLog}
\end{figure}

\newpage
\subsection{Design Process Review}

\newpage

\section{High Level Program Design }
\subsection{Overview of Design}
\textbf{Data Flow / Structure}
\newline
The input net list is in the form of a txt file with two output files: output\verb|_|current and output\verb|_|voltage . The output files are in a CSV format with each line denoting a time instance. The parser creates a circuit object passes that as well as the transient time step and time period. Transient analysis then loops through the Transient solver recursively performing KCL solver. From this we agreed upon data inputs and outputs to each function.

\begin{figure}[h]
    \caption{Overview of data flow}
    \centering
    \includegraphics[width=\textwidth]{images/Comphpp.jpg}
    \label{fig:AlgoOverview}
\end{figure}

FILL ME IN WITH MORE DESIGN

\newpage
\subsection{Circuit Class}
\subsection{Conductance Matrix}
In order to perform a transient simulation we evaluated the node voltages of the circuit at each successive instant in time. This is done by applying KCL at each node in the Circuit and then solve the set of simultaneous equations obtained.\bigbreak
To solve the problem computationally we resorted to linear algebra and decided to write the set of simultaneous equations in the following form
\begin{figure}[h]
    \caption{Circuit analysis equations}
    \centering
    \includegraphics[width=5cm]{images/Conductance_Matrix.PNG}
    \label{fig:ConductanceMat}
\end{figure}

where, starting form the left, we have the conductance Matrix, the vector containing the voltages at each node in the circuit and the vector containing the currents flowing into each node
\subsubsection{linear components}
For Resistor, Voltage-Controlled-Current-Source and Current source the approach was to insert the defining equation of the given component in the set of linear equations. 
\subsubsection{non-linear components}
For Capacitor, Inductor and Diode we first had to linearize the respective defining equation.
This was done by replacing each component in the circuit by its respective linear companion model (see \cite{LinearCompanionModels}) and use the new linear equations to solve the matrix\bigbreak

Note that linear Companion models have been preferred to numerical integration by trapezoidal rule because the former method produces more accurate results
\subsubsection{voltage components}
Due to their nature (infinite conductance) voltage components had to be treated specially.Their equation is written in the matrix after all the other components have been dealt with. Effectively the row corresponding to the anode of the component is added to the row corresponding to the cathode (supernode) and then is replaced with the defining equation of the voltage component.
\begin{figure}[h]
    \caption{Circuit analysis equations containing a voltage source}
    \centering
    \includegraphics[width=5cm]{images/Voltage_source_matrix.PNG}
    \label{fig:VoltCompConductanceMat}
\end{figure}
\subsection{GUI and main}



\newpage



\section{Component Models}
The following section will go through the models and implementations for each Electrical component in our simulation.
A Component is a class with a name, an anode, a cathode and some specialized methods and data-members
\begin{figure}[h]
    \caption{Component Inheritance tree}
    \centering
    \includegraphics[width=12cm]{images/Comphpp1.jpg}
    \label{fig:Comp}
\end{figure}

\subsection{Current Components}
Current components , have virtual function called get\verb|_|current() that allows the any component that is a current component to be cast into a current component and have its get\verb|_|current function called , conveniently allowing differentiation between components of different properties in KCL solver and avoiding needless selection.
\bigbreak
See Appendix A (Current Components) for implementation.
\medbreak


\subsubsection{Resistor}
The resistor is a simple component to implement with respect to our design hence a simple self produced model was used. The class contained a resistance and conductance variables and a get\verb|_|current method which took the node voltages and resistance of the component. \bigbreak\\$Current = \frac{VAnode - VCathode}{R}$
\bigbreak
See Appendix A (Resistor) for implementation.
\newpage
\subsubsection{Capacitor}
The capacitor is an energy storage component , hence the transient analysis of such a component requires the use of a companion model to be formed. Multiple were researched that can represent both the capacitor: Backward Euler , Forward Euler and Trapezoidal Rule. It is possible to derive the next voltage of a capacitor from its differential equation:
\bigbreak

$I = C\frac{dv}{dt}$
\medbreak
$V_{n+1} = V_n + \Delta t\frac{dV_{n+1}}{dt}$
\medbreak
$V_{n+1} = V_n + \frac{\Delta t}{C}i_{n+1}$
\medbreak
$I_{n+1} = \frac{C}{\Delta t}(V_{n+1}-V_n)$
\bigbreak

Thus we can interpret this simplified equation into a companion model, that gives us: 

\bigbreak

\begin{figure}[h]
    \caption{Capacitor Model}
    \centering
    \includegraphics[width=\textwidth]{images/CapModel.jpg}
    \label{fig:CapModel}
\end{figure}

\bigbreak

\noindent\begin{minipage}{.4\linewidth}
\begin{equation}
  Conductance = \frac{C}{\Delta t}
\end{equation}
\end{minipage}%
\begin{minipage}{.7\linewidth}
\begin{equation}
  LinearCurrent = Conductance*V_n
\end{equation}
\end{minipage}

\bigbreak 

Thus for our transient analysis we now have a linear model for our conductance matrix. Conductance remains constant from the start of the simulation to finish. However the value of Linear Current is updated on every time step , as the value of Vn changes from from step to step.

\bigbreak 

See Appendix A (Capacitor) for implementation.

\newpage
\subsubsection{Inductor}
The inductor is the dual of the capacitor hence similar results apply (Same Backward and Forward Euler models). We end up with a similar derivation:
\bigbreak

$V = L\frac{di}{dt}$
\medbreak
$I_{n+1} = I_n + \Delta t\frac{dI_{n+1}}{dt}$
\medbreak
$I_{n+1} = I_n + \frac{\Delta t}{L}V_{n+1}$

\bigbreak

Thus we can interpret this simplified equation into a companion model, that gives us: 

\bigbreak

\begin{figure}[h]
    \caption{Inductor Model}
    \centering
    \includegraphics[width=\textwidth]{images/InductorModel.jpg}
    \label{fig:InductorModel}
\end{figure}

\noindent\begin{minipage}{.5\linewidth}
\setcounter{equation}{0}
\begin{equation}
  Conductance = \frac{\Delta t}{L}
\end{equation}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{equation}
  LinearCurrent = i_n
\end{equation}
\end{minipage}

\bigbreak

Thus for our transient analysis we now have a linear model for our conductance matrix. Conductance remains constant from the start of the simulation to finish. However the value of Linear Current is the result of the previous calculation thus In is the summation of all previous $ N * \frac{\Delta t}{L}V_{n+1}$

\bigbreak

See Appendix A (Inductor) for implementation.

\newpage

\subsubsection{Final Energy Storage component models}
Both components have a range of companion models associated with them. 

\begin{figure}[h]%
    \centering
    \subfloat[Capacitor Models]{{\includegraphics[width=5cm]{images/CapModels.PNG} }}%
    \qquad
    \subfloat[Inductor Models]{{\includegraphics[width=5cm]{images/IndModels.PNG} }}%
    \caption{2 Energy Storage Models}%
    \label{fig:example}%
\end{figure}

Our choice of model was made to ensure accuracy and speed of simulation. Thus Trapezoidal calculation introduces error due over and under estimation of area, whilst also being computationally intense. Thus forward or backward Euler were chosen . Our model represents these Euler methods which allowed for increased speed and accuracy. Both used Norton equivalent models as conductance was our preferred calculation parameter (instead of resistance) hence , a slight accuracy error may occur in the capacitor model as computers may have trouble dividing by a small $\Delta t$.



\subsubsection{Current Source}
A Current Source is implemented by adding constants to the vector of currents. Such constant is returned by the get\_current method.\bigbreak
See Appendix A (Current Source) for implementation
\subsubsection{Voltage Controlled Current Source}
\subsection{Voltage Components}
Voltage components , have virtual function called get\verb|_|Voltage() that allows the any component that is a voltage component to be cast into a voltage component and have its get\verb|_|Voltage() function called , conveniently allowing differentiation between components of different properties in KCL solver and avoiding needless selection.
\medbreak

\subsubsection{Voltage Source}
A voltage source is characterized by the equation $V_{anode}-V_{cathode}=V_{src}$. V_{src} is returned by the get\_Voltage function.\bigbreak
See Appendix A (Voltage Source) for implementation

\subsubsection{Voltage Controlled Voltage Source}
A Voltage Controlled Voltage Source is characterized by the equation
$V_{anode}-V_{cathode}=gain*(V_{control\_anode}-(V_{control\_cathode})$.
The parameter gain is returned by the get\_gain function\bigbreak
See Appendix A (Voltage Controlled Voltage Source) for implementation


\subsubsection{AC Voltage Source}
The AC voltage source is a source with sinusoidal voltage output that is set by a SINE waveform in SPICE, the source has a number of parameters: Amplitude , Frequency , DC Offset and a current voltage (Phase was omitted as we only modelled SINE waves without). The component was simple to implement and required a simple Set and Get methods to access the current voltage. 
The Set function changes the value of current\verb|_|Voltage depending on the Current Time: Current Time = T
\medbreak

$ CurrentVoltage = V_{Amp}  \sin{(2\pi f T)} + Dc $
\medbreak
The get function then returns this value of current Time allowing it to be updated and displayed.
\bigbreak
See Appendix A (AC Voltage Source) for implementation.
\newpage

\subsection{Semiconductor Components}
\subsubsection{Diode}
Unlike the other components discussed so far, diodes do not have a linear relationship between voltage and current. This means that using a linear matrix method to solve the circuit would not be possible when non-linear components such as diodes are present. However, due to the exponential formula for the current through a diode an analytical solution is often far too complex and even impossible. Therefore, the iterative Newton-Raphson technique for solving equations had to be used. This algorithm is discussed in detail in the Transient Solver section, with it resulting in a linear implementation of the diode component.
\\
Inside SPICE the current equation of a diode is dependent on several parameters. 
\begin{itemize}
    \item Is
    \item N
    \item BV
    \item Rs
    \item GMIN (universal constant)
\end{itemize}
Using these parameters the current through the diode is broken down into three sections. When the voltage across the diode is greater than $-5NVt$ (where $Vt = kT/q$ and is taken universally within the simulator to be 0.0258641) the equation is the standard Shockley equation.\bigbreak \\ $I = Is*(e^{\frac{Vd}{N*Vt}}-1) + Vd*GMIN$. \\\bigbreak GMIN is simply the min conductance of the diode and represents a resistor in parallel to it aiding in convergence. When Vd is less than $-5NVt$ but greater than BV the exponential is not worked out as it is insignificant next to the effect of GMIN. BV represents the breakdown voltage of the diode and when VD is less than it the equation is modified.\bigbreak
\\$I = -Is*(e^{-\frac{BV+Vd}{N*Vt}}-1+\frac{BV}{Vt})$\\\bigbreak
The value Rs represents the connection resistances of the diode and is equivalent to a resistor in series with the diode described by these equations. The diode that is implemented in our simulator is the 1N194 and has values taken from LTspice of $Is=2.5n$, $Rs=0.568$, $N=1.752$ and $BV = -70$.  
\\
In order for the iterative technique to be implemented an ideal diode has to be implemented as a current source in parallel with a resistor, as any linear voltage current relationship can be simplified to this. It would be possible to represent the diode as a voltage source and resistor in parallel but this would make generating matrix coefficient harder due to the presence of an extra node. It would also be slower due to voltage sources being more complex to compute in our matrix solver algorithm. Three functions had to be implemented to set the values of the current source and resister which were as follows.
\begin{itemize}
    \item Set Vd (double \_vd)
    \item Set id0 (double (\_ido)
    \item Set Conductance
\end{itemize}

Set Vd and Set ido are simply needed to set the current through the diode and voltage across it at the last iteration. Set Conductance is needed to set the conductance of the resistor in the linear model. This had to be equal to the partial derivative of the diode current equation with respect to voltage. This partial derivative is broken down into three sections to match the current equation described above with the section relating to the Shockley equation as follows.\bigbreak
\\$G = \frac{Is}{N*Vt}*e^{\frac{Vd}{N*Vt}}$\\\bigbreak
Unfortunately, the conductance and linear current of the diode could not be used immediately inside of the KCL solver algorithm. This is due to the presence of the a series resister in the diode model. One approach to this problem could have been to add a resistor in series with the diode in the circuit, but this would have added another node thus increasing the complexity of our matrix and slowing down the simulation. Instead the dependence of the current through the diode on the voltage at each node is calculated as well as the constant current emitted by it. Three functions were made to implement this. 
\begin{itemize}
    \item Get Anode Coefficient
    \item Get Cathode Coefficient
    \item Get Constant Coefficient
\end{itemize}
The outputs of these function can be read directly into the conductance matrix and current vector within the KCL algorithm. The derivation for these values is shown using the circuit in figure \ref{fig:diode}\bigbreak
\\$(V_0-V_1)*G_s = (V_1-V_2)*G_l - I_l$\bigbreak
\\$V_1 = \frac{V_0*G_s + V_2*G_l - I_l}{G_s+G_l}$\bigbreak
\\And so the current passing through $G_s$ is given by:\bigbreak
\\$V_0*Gs - \frac{V_0*G_s^2}{G_s+G_r} - \frac{V_2*G_r*G_s}{G_s+G_r} + \frac{I_l*G_s}{G_s+G_r}$\bigbreak
\\Thus the coefficients can be taken from this equation. \bigbreak
\\$V_0$ coefficient is given by $Gs - \frac{G_s^2}{G_s+G_r}$\bigbreak
\\$V_2$ coefficient is given by $- \frac{G_r*G_s}{G_s+G_r}$\bigbreak
\\The constant coefficient is given by $\frac{I_l*G_s}{G_s+G_r}$\bigbreak
These three terms completely describe the diode model with the KCL solver algorithm as the GMIN value is added to the value of $G_l$. The presence of this series diode presents another problem though. In order for the linear current and conductance to be set by the Transient Solver algorithm the voltage across the diode is needed. However, this is no-longer simply the voltage across the terminals due to the presence of Rs. In order to account for this when setting the voltage across the diode the voltage across Rs, calculated using the current through the diode is subtracted from the voltage between the nodes. 
\begin{figure}[h]
    \caption{Linear Model of Diode}
    \centering
    \includegraphics[width=0.25\textwidth]{images/DiodeCircuit.png}
    \label{fig:diode}
\end{figure}

\newpage

\subsubsection{BJT}
In order to model BJT's within our simulator we used the the Ebers Moll model. This consists of two diodes in parallel with two current dependent current sources. The current sources each provide a current proportional to the current passing through the corresponding diode as can be seen in figure \ref{fig:EbersMoll}. The advantage of using the Ebers Moll model is that is works over the entire operating range of the BJT meaning only one model has to be used. The model's only nonlinear component is a diode which also provides an advantage in that we can use our preexisting method for finding a solution to circuits with diodes present. \\
Within Spice a BJT is defined by several parameters with the ones we used being: 
\begin{itemize}
    \item $I_S$
    \item $R_b$
    \item $R_c$
    \item $R_e$
    \item $\beta_r$
    \item $\beta_f$
\end{itemize}
$I_s$ is needed for the diode equations, both diodes use the same value and $R_b, R_c$ and $R_e$ are the connection resistance of each of the terminals. $\beta_f$ and $\beta_r$ are used to define the current gains, these relate to $\alpha_r$ and $\alpha_f$ with this equation. \bigbreak
$\beta = \frac{\alpha}{1-\alpha}$\bigbreak
\begin{figure}[h]
    \caption{Ebers Moll Model}
    \centering
    \includegraphics[width=0.5\textwidth]{images/EbersMoll.png}
    \label{fig:EbersMoll}
\end{figure}
When the connection resistors are added to the model and the diodes are displayed using their linear models from the iterative algorithm the circuit becomes that shown in figure \ref{fig:LinearEbersMoll}. As in the case of the diode adding connection resistors makes calculating the dependence of current on node voltages more complicated. We could simply add connection resistors directly in our circuit but this would increase the number of nodes and so the complexity of our matrix. In order to represent the BJT's in the conductance matrix the current at each node will need to be calculated in terms of the voltage at each node and a constant term. In order to derive these terms we first started with a set of KCL equations at each of the inner nodes. \bigbreak
$(V_c-V_1)*G_c = (V_1-V_0)*G_r - I_r + \alpha_r*I_f + \alpha_r*G_f*(V_0-V_2)$\bigbreak
$(V_c-V_1)*G_c + (V_e-V_2)*G_e + (V_b-V_2)*G_b = 0$\bigbreak
$(V_e-V_2)*G_e = (V_2-V_0)*G_f - I_f + \alpha_f*I_r + \alpha_f*G_r*(V_0-V_1)$\bigbreak
These equations then need to be rearranged to give $V_0$, $V_1$ and $V_2$ in terms of the other variables so the current at each node can be calculated. This proved difficult to do by hand and so MatLab was used to rearrange the equations. This resulted in these equations.\bigbreak
$D = G_b*G_c*G_e + G_b*G_c*G_f + G_c*Ge*G_f + G_b*Ge*Gr + G_b*G_f*Gr + G_c*Ge*Gr + G_c*G_f*Gr + Ge*G_f*Gr
            - \alpha_f*Gc_*G_e*G_r - \alpha_r*G_c*G_e*G_f - \alpha_f*\alpha_r*G_b*G_f*G_r - \alpha_f*\alpha_r*G_c*G_f*G_r - \alpha_f*\alpha_r*G_e*G_f*G_r$\bigbreak
$V_0 = (\alpha_f*G_c*G_e*I_r - G_c*G_e*I_r - G_c*G_f*I_r - G_e*G_r*I_f - G_c*G_e*I_f + \alpha_r*G_c*G_e*I_f + G_b*G_c*G_e*V_b + G_b*G_c*G_f*V_b + G_c*G_e*G_f*V_e + G_b*G_e*G_r*V_b + G_b*G_f*G_r*V_b + G_c*G_e*G_r*V_c + G_c*G_f*G_r*V_c + G_e*G_f*G_r*V_e + \alpha_f*\alpha_r*G_c*G_f*I_r + 
\alpha_f*\alpha_r*G_e*G_r*I_f - \alpha_f*G_c*G_e*G_r*V_c - \alpha_r*G_c*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
$V_2 = (G_b*G_c*I_f + G_b*G_r*I_f - G_c*G_f*I_r + G_c*G_r*I_f - \alpha_f*G_b*G_c*I_r + G_b*G_c*G_f*V_b + G_b*G_c*G_e*V_e + G_c*G_e*G_f*V_e + G_b*G_f*G_r*V_b + G_b*G_e*G_r*V_e + G_c*G_f*G_r*V_c + G_c*G_e*G_r*V_e + G_e*G_f*G_r*V_e - \alpha_f*\alpha_r*G_b*G_r*I_f + \alpha_f*\alpha_r*G_c*G_f*I_r - \alpha_f*\alpha_r*G_c*G_r*I_f - \alpha_f*G_b*G_c*G_r*V_b + \alpha_f*G_b*G_c*G_r*V_c - \alpha_f*G_c*G_e*G_r*V_e - \alpha_r*G_c*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
$V_1 = (G_b*G_e*I_r + G_b*G_f*I_r + G_e*G_f*I_r - G_e*G_r*I_f - \alpha_r*G_b*G_e*I_f + G_b*G_c*G_e*V_c + G_b*G_c*G_f*V_c + G_c*G_e*G_f*V_c + G_b*G_e*G_r*V_b + G_b*G_f*G_r*V_b + G_c*G_e*G_r*V_c + G_c*G_f*G_r*V_c + G_e*G_f*G_r*V_e - \alpha_f*\alpha_r*G_b*G_f*I_r - \alpha_f*\alpha_r*G_e*G_f*I_r + \alpha_f*\alpha_r*G_e*G_r*I_f - \alpha_r*G_b*G_e*G_f*V_b - \alpha_f*G_c*G_e*G_r*V_c - \alpha_r*G_c*G_e*G_f*V_c + \alpha_r*G_b*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
\begin{figure}[h]
    \caption{Ebers Moll Linear Model}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LinearEbersMoll.png}
    \label{fig:LinearEbersMoll}
\end{figure}
From these equations the current at each of the nodes can be given in terms of the correct node voltages and constants. In order to implement this model with these equations four methods are used within the BJT:
\begin{itemize}
    \item Set OP
    \item Get Collector Coefficient (double Node)
    \item Get Emitter Coefficient (double Node)
    \item Get Constant Coefficients (double Node)
\end{itemize}
Set OP has to be called at the beginning of each iteration within the Transient Solver algorithm and sets the operating points of the diodes. In order to do this it has to subtract the voltage across the connection resistor (calculated using the current through the nodes) to find the voltage across the diodes. The diodes are set in the same way as previously described in the diode section. The denominator D in the equations above is then also calculated so it does not have to be re-calculated each time by each of the coefficient functions. The coefficient functions each provide the dependence of current on their respective node voltages for the node given by the parameter. When the coefficients are calculated they are saved as this speeds up calculating the current later on. The equations in these methods are sped up by calculating the multiplication of constants in the diode constructor and storing them, such as $G_b*G_e*G_c$ as well as factorising the equation where possible as can be seen in figure \ref{fig:BJTCollector}.    
\begin{figure}[h]
    \caption{BJT Collector Coefficient Generator}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTCollector.png}
    \label{fig:BJTCollector}
\end{figure}
After voltages have been calculated in a circuit the BJT is also required to have a method to calculate the current passing through it. Unlike the other components the BJT GetCurrent method return a vector<double> as opposed to a double. The fist value in the vector represents the current going into the collector, the second the base, and the third the emitter. When the coefficients for each node were calculated earlier when calculating voltages they were stored in three vectors. This means that using the voltages the currents can quickly be calculated, this is shown in figure \ref{fig:BJTCurrent}. 
\begin{figure}[h]
    \caption{BJT Current Generator}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTCurrent.png}
    \label{fig:BJTCurrent}
\end{figure}
The BJT used within our simulation was the 2N2222, which has values of $I_S = 10^{-14}$, $R_b = 10$, $R_c = 0.3$, $R_e - 0.2$, $\beta_r = 3$ and $\beta_f = 200$.
\newpage

\section{Analysis Algorithms}\label{sec:AnalysisAlgorithms}
\subsection{Parser}\label{ssec:parser}
The role of Parser.hpp is to read an input text file (compatible with a SPICE netlist) that defines the circuit and the simulation.\medbreak
In the input file each component has a unique designator letter \bigbreak
Reference:\ref{ss}
\begin{figure}[h]
    \caption{Components input format}
    \centering
    \includegraphics[width=1\textwidth]{images/components_input_format.PNG}
    \label{fig:ComponentsInputFormat}
\end{figure}
Firstly Parser.hpp constructs an empty Circuit instance, it then peeks the first character of each line of the input file.
\begin{itemize}
\item If the first character is a \textit{designator letter}, it constructs a new Component in the heap with the aid of read\_value and read\_node\_number functions, then it updates the Circuit instance by using the Circuit::add\_component function.
\item If the first string of the line is \textit{.tran} it then proceeds to run a Transient analysis of the Circuit
\item If the first character is a \textit{*} it ignores the line because it is a comment
\item If the first string of the line is \textit{.end} it closes the input file
\end{itemize}



\subsection{Transient Analysis}
\subsection{KCL Solver}
The role of KCL\_Solver is to solve for the Circuit voltages at a given instant in time.\\
\subsubsection{Eigen3 library}
\subsubsection{Construct and solve the conductance matrix}
The function Matrix\_solver receives a fully updated Circuit instance from
Transient Analysis. It then
\newpage
\subsection{Transient Solver}
When non-linear components such as BJT's and diodes are present in a circuit solving the circuit using linear algebra is no-longer possible. Due to the complexity of diode and BJT equations the method used to solve these non-linear circuits is the iterative Newton-Raphson method. The equation that describes the iterative method is:
\bigbreak $x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$\bigbreak
By repeating this iteration $x_n$ may converge such that $f(x_n) = 0$
Originally we considered that due to the presence of many node voltages in a circuit and a diode current being dependent on two of those voltages a multi-variable method would have to be used. We researched how to modify the above equation for multi variable equations and found a lecture\cite{mulitvariableNR} describing the use of a Jacobian matrix. We tried implementing this method by giving each current component a function that returns a vector storing the partial derivatives of its current with respect to each current. However, we where never able to get this method to converge correctly with diodes, with the method also adding a lot of extra code and computation. Having tried this method we then found after more research that we could describe the current through the diode as a function of the voltage across it which is only one variable\cite{LinearCompanionModels}, so the use of multi-variable iteration was not needed. In order to solve the diode using Newton-Raphson we need to form an KCL equation that is equal to 0. Doing KCL at the diodes anode we have the equation:
\bigbreak $I_d - I_{in} = 0$\bigbreak
Where $I_in$ is the current entering the diode and $I_d$ is the current due to the diode current equation. Combining this with Newton-Raphson gives:
\bigbreak $x_{n+1} = x_n - \frac{I_d - I_{in}}{\frac{d I_d}{d V_d}}$\bigbreak
The Newton Raphson method the function each iteration as a linear function and so a diode is going to need to be modeled as a resistor and current source in parallel as any linear voltage current relationship can be modelled as this, (apart from those with an infinite gradient). I we consider a diode as a current source in parallel with a resistor we can again do KCL at its anode to form the equation. 
\bigbreak $V_d*G_l + I_l - I_{in} = 0$ Where $G_l$ and $I_l$ are the conductor and current source values.\bigbreak
We want to find a value of $G_l$ and $I_l$ such that if we solve the circuit using the KCL solver algorithm the voltage across the diode will be $V_{n+1}$
\bigbreak
Thus if we rearrange the Newton-Raphson equation we have:\bigbreak
$x_{n+1}*\frac{d I_d}{d V_d} = x_n*\frac{d I_d}{d V_d} - I_d + I_{in}$\bigbreak
From this we can see that if we make $G_l = \frac{d I_d}{d V_d}$ and $I_l = I_d - x_n*\frac{d I_d}{d V_d}$ when the equation is solved the voltage across the diode will be $V_{n+1}$\bigbreak
If we keep repeating this method of setting the value of G and I for each diode and then solving the circuit and then resetting the values the circuit should converge to the correct values. To complete the iterations though we need some way of telling when the circuit has converged to an acceptable accuracy. 
Within Spice two parameters are used to measure this convergence.
\begin{itemize}
    \item RELTOL
    \item ABSTOL
\end{itemize}
Spice combines these two parameters within the inequality $|v_{n+1}-x_n| < RELTOL*|x_n| + ABSTOL$.\\
RELTOL measures the relative change in the voltage and ABSTOL is present as near 0V $RELTOL*|x_n|$ may become too small. Each iteration of our algorithm each of the node voltages is compared using this inequality to the previous voltage and if all the inequalities return true the algorithm finishes. A maximum number of iterations is set so that the program can't get stuck in an infinite loop. Within our program the max iterations was set to 1000 as we found that a correct circuit usually has a max iterations of a few hundred on the first time step and so this provides room for that occur. We set RELTOL and ABSTOL to values of $10^{-3}$ and $10^{-12}$ respectively. This provided a trade off between accuracy and speed of our program. If higher accuracy is needed RELTOL should be decreased. 
\bigbreak
In order to implement this algorithm the flow diagram shown in figure \ref{fig:transient}. The entire algorithm is contained within one function called TransientSolver. This function takes a circuit object by reference and modifies its voltages to the correct voltages given components in the circuit or exits the program if the maximum iterations is reached. This means that the starting guess for the voltage is the voltages from the previous time instance meaning that they are very close to the new voltages. This results in very few iterations normally being needed. Only the first iteration with starting guesses of 0V takes many iterations under normal use. \\

The algorithm runs within a while loop, starting by looping through all the components and setting the linear current and conductance of all diodes and BJT's. As BJT's are simply modelled as containing two diodes they converge in the same manner as diodes do. The algorithm then saves the circuit voltages in a vector before running the KCL solver algorithm on the circuit. After this it compares the old voltages with new and breaks the while loop if complete.  

\begin{figure}[h]
    \caption{Transient Solver Algorithm}
    \centering
    \includegraphics[width=0.5\textwidth]{images/TransientSolverAlgorithm.png}
    \label{fig:transient}
\end{figure}

\newpage

\section{Application Features and Innovation}
\subsection{QT Container and Application}
Biggest innovations: 
QT
Used derivations to eliminate mathematical complexity and faster implementation: In diode and BJT. 



\section{Testing and Evaluation}

\section{Final Evaluation}

\newpage



\bibliographystyle{plain}
\bibliography{bibliography.bib}

\appendix
\section{Appendix}
\textbf{Current Component}
\bigbreak
\includegraphics[width=12cm]{images/Current_Component.PNG}
\bigbreak
\textbf{Resistor}
\bigbreak
\includegraphics[width=12cm]{images/Resistor.PNG}
\bigbreak
\newpage
\textbf{Capacitor}
\bigbreak
\includegraphics[width=12cm]{images/Capacitor.PNG}
\bigbreak
\newpage
\textbf{Inductor}
\bigbreak
\includegraphics[width=12cm]{images/INDUCTOR.PNG}
\bigbreak

\end{document}
