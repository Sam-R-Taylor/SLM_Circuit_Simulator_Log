\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{float}


\usepackage{titlesec}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}









\title{SLM Circuit Simulator Log}
\author{Sam Taylor, Maximus Wickham , Leonardo Garofalo}
\date{June 2020}

\pagestyle{fancy}
\fancyhf{}
\rhead{SLM Soloutions}
\lhead{SLM Circuit Sim}
\rfoot{Page \thepage}

\graphicspath{ {./images/} }
\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Engineering Design Process}
\flushleft

\subsection{Outline of technical problem to be solved:}
\flushleft

\smallbreak
Write a software package that performs a transient simulation of a circuit, like LTspice. The main elements of such a system are described below:
\newline
\smallbreak
1. Parse the netlist file using reduced SPICE format.
\newline
2. Set up the simulation (Transient Analysis , DC Bias Point Analysis)
\newline
3. Construct and solve the conductance matrix
\newline
4. Process voltage sources
\newline
5. Write the output
\newline
6. Add support for non-linear components (advanced)
\newline
\mediumbreak 

Key Evaluation points:
\newline
1. Accuracy: compare the outputs to pen and paper solutions. 
\newline
2. Efficiency: find how long the simulation takes and, by estimating the power consumption of your computer.

\subsection{Software Requirements Specification:}
\flushleft
\textbf{Outline:} A circuit Simulation that produces transient analysis for circuits containing energy storage devices , diodes and transistors . With reasonable accuracy and speed.

\bigbreak

\textbf{Functional Requirements}

\newline

1. Give Node Voltages of a complete circuit within 1 percent of Spice
\newline
2. Evaluate Current flowing through each component within 1 percent of Spice
\newline
3. Perform analysis for passive, energy storage devices , diodes and transistors.
\newline
4. Take input from a reduced spice netlist file.
\newline
5. Output analysis to an output file.
\newline
6. The software must be capable of dealing with both linear and non-linear devices

\bigbreak

\textbf{Non-Functional Requirements}
\newline
1.The software must be capable of analyse different kinds of circuits
\newline
2. The software must be able to perform the analysis in a fast and efficient way
\newline
3. The software must be capable of performing the analysis consuming the least amount of power possible

\newpage
\subsection{Design Process and Project management}

We chose to use the Scrum framework to manage our collaboration during the project. We initially populated the project backlog with details from the specification and our design overview. Each morning (at varying times) we held a thirty minute scrum to inform each other what we work we would be doing that day. At the end of each day we held a second meeting to discuss what was achieved and what problems we encountered updating the backlog with completed and new tasks.
We also held a bi-weekly sprint meeting where we determined the milestone and objectives of that sprint. We did not use a sprint backlog just kept a single updated backlog. 

\begin{figure}[h]
    \caption{Scrum Framework work pattern}
    \centering
    \includegraphics[width=\textwidth]{images/ScrumFramework.jpg}
    \label{fig:Scrum}
\end{figure}
We also used a timeline to keep general project discipline and keep goals realistic to the final deadline. This was used to ensure we were not implementing more functionality beyond our ability to produce a write up.
\begin{figure}[h]
    \caption{Snapshot of Onenote backlog}
    \centering
    \includegraphics[width=12cm]{images/Backlog.PNG}
    \label{fig:BackLog}
\end{figure}

\newpage
\subsection{Design Process Review}


Reviewing our timeline and working procedures revealed to me some key points to work better on projects in future:
\begin{figure}[h]
    \caption{Timeline of project progression}
    \centering
    \includegraphics[width=0.7\linewidth]{images/Timeline.PNG}
    \label{fig:Timeline}
\end{figure}


\newpage

\section{High Level Program Design }
\subsection{Overview of Design}
\textbf{Data Flow / Structure}
\newline
The input net list is in the form of a txt file with two output files: output\verb|_|current and output\verb|_|voltage . The output files are in a CSV format with each line denoting a time instance. The parser creates a circuit object passes that as well as the transient time step and time period. Transient analysis then loops through the Transient solver recursively performing KCL solver. From this we agreed upon data inputs and outputs to each function.

\begin{figure}[h]
    \caption{Overview of data flow}
    \centering
    \includegraphics[width=\textwidth]{images/Comphpp.jpg}
    \label{fig:AlgoOverview}
\end{figure}

FILL ME IN WITH MORE DESIGN

\newpage
\subsection{Circuit Class}
The aim of the circuit class was to provide an object that is instantiated by the user input to store information of the components , nodes and other elements of simulation. The Object acted to provide a guarantee of how data was formatted and what data is stored. It holds a number of key fields:
\medbreak
\noindent\begin{minipage}{.5\linewidth}
\begin{itemize}
    \item vector of Nodes
    \item vector of Components
    \item vector of voltages(doubles)
\end{itemize}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{itemize}\break
    \item GMIN
    \item ABSTOL
    \item RELTOL
    \item max\verb|_|iterations
\end{itemize}
\end{minipage}
\medbreak
It is also used to set a number of global conditions on simulation such as GMIN for convergence in BJT and Diode simulation:
\medbreak
Circuit has a number of methods that allow each of these stored fields to be accessed , It also has methods to add new elements to each field when the circuit.obj is being constructed. This circuit standard was passed between each function block through simulation ending its lifetime once simulation specified in the netlist is complete.

MAX AND LEO FILL IN PLEASE

\bigbreak
See Appendix A (Circuit) for implementation.
\subsection{Node Struct}
MAX FILL IN
\newpage
\subsection{GUI and main}
We chose to produce a GUI and a maker tool to help simplify the build process for development projects across different platforms as we were using a range of platform for development. It automates the generation of Makefiles so that only a few lines of information are needed to create each Makefile. We chose to use QT , a free and open-source widget toolkit for creating graphical user interfaces as well as cross-platform applications. This allowed us to have a single application environment where we could easily test and deploy a distributable for our work.
\bigbreak
\begin{figure}[h]
    \caption{Application example operation displaying voltage at node 2 for a full wave rectifier}
    \centering
    \includegraphics[width=1\textwidth]{images/AppEx.PNG}
    \label{fig:AppEx}
\end{figure}
Hence this allowed us to satisfactorily test and ensure correct operation of our program. Ensuring that all was functioning as expected. Further it was designed in such a way to operate completely independently of the main program. Essentially the Qt app only provides output and reads output from the main analysis program. Aside from that it is entirely possible to perform complete analysis from the terminal.


\newpage



\section{Component Models}
The following section will go through the models and implementations for each Electrical component in our simulation.
A Component is a class with a name, an anode, a cathode and some specialized methods and data-members
\begin{figure}[h]
    \caption{Component Inheritance tree}
    \centering
    \includegraphics[width=12cm]{images/Comphpp1.jpg}
    \label{fig:Comp}
\end{figure}

\subsection{Current Components}
Current components , have virtual function called get\verb|_|current() that allows the any component that is a current component to be cast into a current component and have its get\verb|_|current function called , conveniently allowing differentiation between components of different properties in KCL solver and avoiding needless selection.
\bigbreak
See Appendix A (Current Components) for implementation.
\medbreak


\subsubsection{Resistor}
The resistor is a simple component to implement with respect to our design hence a simple self produced model was used. The class contained a resistance and conductance variables and a get\verb|_|current method which took the node voltages and resistance of the component. \bigbreak\\$Current = \frac{VAnode - VCathode}{R}$
\bigbreak
See Appendix A (Resistor) for implementation.
\newpage
\subsubsection{Capacitor}
The capacitor is an energy storage component , hence the transient analysis of such a component requires the use of a companion model to be formed. Multiple were researched that can represent both the capacitor: Backward Euler , Forward Euler and Trapezoidal Rule. It is possible to derive the next voltage of a capacitor from its differential equation:
\bigbreak

$I = C\frac{dv}{dt}$
\medbreak
$V_{n+1} = V_n + \Delta t\frac{dV_{n+1}}{dt}$
\medbreak
$V_{n+1} = V_n + \frac{\Delta t}{C}i_{n+1}$
\medbreak
$I_{n+1} = \frac{C}{\Delta t}(V_{n+1}-V_n)$
\bigbreak

Thus we can interpret this simplified equation into a companion model, that gives us: 

\bigbreak

\begin{figure}[h]
    \caption{Capacitor Model}
    \centering
    \includegraphics[width=\textwidth]{images/CapModel.jpg}
    \label{fig:CapModel}
\end{figure}

\bigbreak

\noindent\begin{minipage}{.4\linewidth}
\begin{equation}
  Conductance = \frac{C}{\Delta t}
\end{equation}
\end{minipage}%
\begin{minipage}{.7\linewidth}
\begin{equation}
  LinearCurrent = Conductance*V_n
\end{equation}
\end{minipage}

\bigbreak 

Thus for our transient analysis we now have a linear model for our conductance matrix. Conductance remains constant from the start of the simulation to finish. However the value of Linear Current is updated on every time step , as the value of Vn changes from from step to step.

\bigbreak 

See Appendix A (Capacitor) for implementation.

\newpage
\subsubsection{Inductor}
The inductor is the dual of the capacitor hence similar results apply (Same Backward and Forward Euler models). We end up with a similar derivation:
\bigbreak

$V = L\frac{di}{dt}$
\medbreak
$I_{n+1} = I_n + \Delta t\frac{dI_{n+1}}{dt}$
\medbreak
$I_{n+1} = I_n + \frac{\Delta t}{L}V_{n+1}$

\bigbreak

Thus we can interpret this simplified equation into a companion model, that gives us: 

\bigbreak

\begin{figure}[h]
    \caption{Inductor Model}
    \centering
    \includegraphics[width=\textwidth]{images/InductorModel.jpg}
    \label{fig:InductorModel}
\end{figure}

\noindent\begin{minipage}{.5\linewidth}
\setcounter{equation}{0}
\begin{equation}
  Conductance = \frac{\Delta t}{L}
\end{equation}
\end{minipage}%
\begin{minipage}{.5\linewidth}
\begin{equation}
  LinearCurrent = i_n
\end{equation}
\end{minipage}

\bigbreak

Thus for our transient analysis we now have a linear model for our conductance matrix. Conductance remains constant from the start of the simulation to finish. However the value of Linear Current is the result of the previous calculation thus In is the summation of all previous $ N * \frac{\Delta t}{L}V_{n+1}$

\bigbreak

See Appendix A (Inductor) for implementation.

\newpage

\subsubsection{Final Energy Storage component models}
Both components have a range of companion models associated with them. 

\begin{figure}[h]%
    \centering
    \subfloat[Capacitor Models]{{\includegraphics[width=5cm]{images/CapModels.PNG} }}%
    \qquad
    \subfloat[Inductor Models]{{\includegraphics[width=5cm]{images/IndModels.PNG} }}%
    \caption{2 Energy Storage Models}%
    \label{fig:example}%
\end{figure}

Our choice of model was made to ensure accuracy and speed of simulation. Thus Trapezoidal calculation introduces error due over and under estimation of area, whilst also being computationally intense. Thus forward or backward Euler were chosen . Our model represents these Euler methods which allowed for increased speed and accuracy. Both used Norton equivalent models as conductance was our preferred calculation parameter (instead of resistance) hence , a slight accuracy error may occur in the capacitor model as computers may have trouble dividing by a small $\Delta t$.



\subsubsection{Current Source}
A Current Source is implemented by adding constants to the vector of currents. Such constant is returned by the get\_current method.\bigbreak
See Appendix A (Current Source) for implementation
\subsubsection{Voltage Controlled Current Source}
A Voltage Controlled Current Source is characterized by the equation $ Current = gain\cdot(V_{control\_anode}-(V_{control\_cathode})$
\subsection{Voltage Components}
Voltage components , have virtual function called get\verb|_|Voltage() that allows the any component that is a voltage component to be cast into a voltage component and have its get\verb|_|Voltage() function called , conveniently allowing differentiation between components of different properties in KCL solver and avoiding needless selection.
\medbreak

\subsubsection{Voltage Source}
A voltage source is characterized by the equation $V_{anode}-V_{cathode}=V_{src}$. \bigbreak
See Appendix A (Voltage Source) for implementation

\subsubsection{Voltage Controlled Voltage Source}
A Voltage Controlled Voltage Source is characterized by the equation
$V_{anode}-V_{cathode}=gain\cdot(V_{control\_anode}-(V_{control\_cathode})$.
\bigbreak
See Appendix A (Voltage Controlled Voltage Source) for implementation


\subsubsection{AC Voltage Source}
The AC voltage source is a source with sinusoidal voltage output that is set by a SINE waveform in SPICE, the source has a number of parameters: Amplitude , Frequency , DC Offset and a current voltage (Phase was omitted as we only modelled SINE waves without). The component was simple to implement and required a simple Set and Get methods to access the current voltage. 
The Set function changes the value of current\verb|_|Voltage depending on the Current Time: Current Time = T
\medbreak

$ CurrentVoltage = V_{Amp}  \sin{(2\pi f T)} + Dc $
\medbreak
The get function then returns this value of current Time allowing it to be updated and displayed.
\bigbreak
See Appendix A (AC Voltage Source) for implementation.
\newpage

\subsection{Semiconductor Components}
\subsubsection{Diode}
Unlike the other components discussed so far, diodes do not have a linear relationship between voltage and current. This means that using a linear matrix method to solve the circuit would not be possible when non-linear components such as diodes are present. However, due to the exponential formula for the current through a diode an analytical solution is often far too complex and even impossible. Therefore, the iterative Newton-Raphson technique for solving equations had to be used. This algorithm is discussed in detail in the Transient Solver section, with it resulting in a linear implementation of the diode component.
\\
Inside SPICE the current equation of a diode is dependent on several parameters. 
\begin{itemize}
    \item Is
    \item N
    \item BV
    \item Rs
    \item GMIN (universal constant)
\end{itemize}
Using these parameters the current through the diode is broken down into three sections. When the voltage across the diode is greater than $-5NVt$ (where $Vt = kT/q$ and is taken universally within the simulator to be 0.0258641) the equation is the standard Shockley equation.\bigbreak \\ $I = Is*(e^{\frac{Vd}{N*Vt}}-1) + Vd*GMIN$. \\\bigbreak GMIN is simply the min conductance of the diode and represents a resistor in parallel to it aiding in convergence. When Vd is less than $-5NVt$ but greater than BV the exponential is not worked out as it is insignificant next to the effect of GMIN. BV represents the breakdown voltage of the diode and when VD is less than it the equation is modified.\bigbreak
\\$I = -Is*(e^{-\frac{BV+Vd}{N*Vt}}-1+\frac{BV}{Vt})$\\\bigbreak
The value Rs represents the connection resistances of the diode and is equivalent to a resistor in series with the diode described by these equations. The diode that is implemented in our simulator is the 1N194 and has values taken from LTspice of $Is=2.5n$, $Rs=0.568$, $N=1.752$ and $BV = -70$.  
\\
In order for the iterative technique to be implemented an ideal diode has to be implemented as a current source in parallel with a resistor, as any linear voltage current relationship can be simplified to this. It would be possible to represent the diode as a voltage source and resistor in parallel but this would make generating matrix coefficient harder due to the presence of an extra node. It would also be slower due to voltage sources being more complex to compute in our matrix solver algorithm. Three functions had to be implemented to set the values of the current source and resister which were as follows.
\begin{itemize}
    \item Set Vd (double \_vd)
    \item Set id0 (double (\_ido)
    \item Set Conductance
\end{itemize}

Set Vd and Set ido are simply needed to set the current through the diode and voltage across it at the last iteration. Set Conductance is needed to set the conductance of the resistor in the linear model. This had to be equal to the partial derivative of the diode current equation with respect to voltage. This partial derivative is broken down into three sections to match the current equation described above with the section relating to the Shockley equation as follows.\bigbreak
\\$G = \frac{Is}{N*Vt}*e^{\frac{Vd}{N*Vt}}$\\\bigbreak
Unfortunately, the conductance and linear current of the diode could not be used immediately inside of the KCL solver algorithm. This is due to the presence of the a series resister in the diode model. One approach to this problem could have been to add a resistor in series with the diode in the circuit, but this would have added another node thus increasing the complexity of our matrix and slowing down the simulation. Instead the dependence of the current through the diode on the voltage at each node is calculated as well as the constant current emitted by it. Three functions were made to implement this. 
\begin{itemize}
    \item Get Anode Coefficient
    \item Get Cathode Coefficient
    \item Get Constant Coefficient
\end{itemize}
The outputs of these function can be read directly into the conductance matrix and current vector within the KCL algorithm. The derivation for these values is shown using the circuit in figure \ref{fig:diode}\bigbreak
\\$(V_0-V_1)*G_s = (V_1-V_2)*G_l - I_l$\bigbreak
\\$V_1 = \frac{V_0*G_s + V_2*G_l - I_l}{G_s+G_l}$\bigbreak
\\And so the current passing through $G_s$ is given by:\bigbreak
\\$V_0*Gs - \frac{V_0*G_s^2}{G_s+G_r} - \frac{V_2*G_r*G_s}{G_s+G_r} + \frac{I_l*G_s}{G_s+G_r}$\bigbreak
\\Thus the coefficients can be taken from this equation. \bigbreak
\\$V_0$ coefficient is given by $Gs - \frac{G_s^2}{G_s+G_r}$\bigbreak
\\$V_2$ coefficient is given by $- \frac{G_r*G_s}{G_s+G_r}$\bigbreak
\\The constant coefficient is given by $\frac{I_l*G_s}{G_s+G_r}$\bigbreak
These three terms completely describe the diode model with the KCL solver algorithm as the GMIN value is added to the value of $G_l$. The presence of this series diode presents another problem though. In order for the linear current and conductance to be set by the Transient Solver algorithm the voltage across the diode is needed. However, this is no-longer simply the voltage across the terminals due to the presence of Rs. In order to account for this when setting the voltage across the diode the voltage across Rs, calculated using the current through the diode is subtracted from the voltage between the nodes. 
\begin{figure}[h]
    \caption{Linear Model of Diode}
    \centering
    \includegraphics[width=0.25\textwidth]{images/DiodeCircuit.png}
    \label{fig:diode}
\end{figure}

\newpage

\subsubsection{BJT}
In order to model BJT's within our simulator we used the the Ebers Moll model. This consists of two diodes in parallel with two current dependent current sources. The current sources each provide a current proportional to the current passing through the corresponding diode as can be seen in figure \ref{fig:EbersMoll}. The advantage of using the Ebers Moll model is that is works over the entire operating range of the BJT meaning only one model has to be used. The model's only nonlinear component is a diode which also provides an advantage in that we can use our preexisting method for finding a solution to circuits with diodes present. \\
Within Spice a BJT is defined by several parameters with the ones we used being: 
\begin{itemize}
    \item $I_S$
    \item $R_b$
    \item $R_c$
    \item $R_e$
    \item $\beta_r$
    \item $\beta_f$
\end{itemize}
$I_s$ is needed for the diode equations, both diodes use the same value and $R_b, R_c$ and $R_e$ are the connection resistance of each of the terminals. $\beta_f$ and $\beta_r$ are used to define the current gains, these relate to $\alpha_r$ and $\alpha_f$ with this equation. \bigbreak
$\beta = \frac{\alpha}{1-\alpha}$\bigbreak
\begin{figure}[h]
    \caption{Ebers Moll Model}
    \centering
    \includegraphics[width=0.5\textwidth]{images/EbersMoll.png}
    \label{fig:EbersMoll}
\end{figure}
When the connection resistors are added to the model and the diodes are displayed using their linear models from the iterative algorithm the circuit becomes that shown in figure \ref{fig:LinearEbersMoll}. As in the case of the diode adding connection resistors makes calculating the dependence of current on node voltages more complicated. We could simply add connection resistors directly in our circuit but this would increase the number of nodes and so the complexity of our matrix. In order to represent the BJT's in the conductance matrix the current at each node will need to be calculated in terms of the voltage at each node and a constant term. In order to derive these terms we first started with a set of KCL equations at each of the inner nodes. \bigbreak
$(V_c-V_1)*G_c = (V_1-V_0)*G_r - I_r + \alpha_r*I_f + \alpha_r*G_f*(V_0-V_2)$\bigbreak
$(V_c-V_1)*G_c + (V_e-V_2)*G_e + (V_b-V_2)*G_b = 0$\bigbreak
$(V_e-V_2)*G_e = (V_2-V_0)*G_f - I_f + \alpha_f*I_r + \alpha_f*G_r*(V_0-V_1)$\bigbreak
These equations then need to be rearranged to give $V_0$, $V_1$ and $V_2$ in terms of the other variables so the current at each node can be calculated. This proved difficult to do by hand and so MatLab was used to rearrange the equations. This resulted in these equations.\bigbreak
$D = G_b*G_c*G_e + G_b*G_c*G_f + G_c*Ge*G_f + G_b*Ge*Gr + G_b*G_f*Gr + G_c*Ge*Gr + G_c*G_f*Gr + Ge*G_f*Gr
            - \alpha_f*Gc_*G_e*G_r - \alpha_r*G_c*G_e*G_f - \alpha_f*\alpha_r*G_b*G_f*G_r - \alpha_f*\alpha_r*G_c*G_f*G_r - \alpha_f*\alpha_r*G_e*G_f*G_r$\bigbreak
$V_0 = (\alpha_f*G_c*G_e*I_r - G_c*G_e*I_r - G_c*G_f*I_r - G_e*G_r*I_f - G_c*G_e*I_f + \alpha_r*G_c*G_e*I_f + G_b*G_c*G_e*V_b + G_b*G_c*G_f*V_b + G_c*G_e*G_f*V_e + G_b*G_e*G_r*V_b + G_b*G_f*G_r*V_b + G_c*G_e*G_r*V_c + G_c*G_f*G_r*V_c + G_e*G_f*G_r*V_e + \alpha_f*\alpha_r*G_c*G_f*I_r + 
\alpha_f*\alpha_r*G_e*G_r*I_f - \alpha_f*G_c*G_e*G_r*V_c - \alpha_r*G_c*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
$V_2 = (G_b*G_c*I_f + G_b*G_r*I_f - G_c*G_f*I_r + G_c*G_r*I_f - \alpha_f*G_b*G_c*I_r + G_b*G_c*G_f*V_b + G_b*G_c*G_e*V_e + G_c*G_e*G_f*V_e + G_b*G_f*G_r*V_b + G_b*G_e*G_r*V_e + G_c*G_f*G_r*V_c + G_c*G_e*G_r*V_e + G_e*G_f*G_r*V_e - \alpha_f*\alpha_r*G_b*G_r*I_f + \alpha_f*\alpha_r*G_c*G_f*I_r - \alpha_f*\alpha_r*G_c*G_r*I_f - \alpha_f*G_b*G_c*G_r*V_b + \alpha_f*G_b*G_c*G_r*V_c - \alpha_f*G_c*G_e*G_r*V_e - \alpha_r*G_c*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
$V_1 = (G_b*G_e*I_r + G_b*G_f*I_r + G_e*G_f*I_r - G_e*G_r*I_f - \alpha_r*G_b*G_e*I_f + G_b*G_c*G_e*V_c + G_b*G_c*G_f*V_c + G_c*G_e*G_f*V_c + G_b*G_e*G_r*V_b + G_b*G_f*G_r*V_b + G_c*G_e*G_r*V_c + G_c*G_f*G_r*V_c + G_e*G_f*G_r*V_e - \alpha_f*\alpha_r*G_b*G_f*I_r - \alpha_f*\alpha_r*G_e*G_f*I_r + \alpha_f*\alpha_r*G_e*G_r*I_f - \alpha_r*G_b*G_e*G_f*V_b - \alpha_f*G_c*G_e*G_r*V_c - \alpha_r*G_c*G_e*G_f*V_c + \alpha_r*G_b*G_e*G_f*V_e - \alpha_f*\alpha_r*G_b*G_f*G_r*V_b - \alpha_f*\alpha_r*G_c*G_f*G_r*V_c - \alpha_f*\alpha_r*G_e*G_f*G_r*V_e)/D$\bigbreak
\begin{figure}[h]
    \caption{Ebers Moll Linear Model}
    \centering
    \includegraphics[width=0.5\textwidth]{images/LinearEbersMoll.png}
    \label{fig:LinearEbersMoll}
\end{figure}
From these equations the current at each of the nodes can be given in terms of the correct node voltages and constants. In order to implement this model with these equations four methods are used within the BJT:
\begin{itemize}
    \item Set OP
    \item Get Collector Coefficient (double Node)
    \item Get Emitter Coefficient (double Node)
    \item Get Constant Coefficients (double Node)
\end{itemize}
Set OP has to be called at the beginning of each iteration within the Transient Solver algorithm and sets the operating points of the diodes. In order to do this it has to subtract the voltage across the connection resistor (calculated using the current through the nodes) to find the voltage across the diodes. The diodes are set in the same way as previously described in the diode section. The denominator D in the equations above is then also calculated so it does not have to be re-calculated each time by each of the coefficient functions. The coefficient functions each provide the dependence of current on their respective node voltages for the node given by the parameter. When the coefficients are calculated they are saved as this speeds up calculating the current later on. The equations in these methods are sped up by calculating the multiplication of constants in the diode constructor and storing them, such as $G_b*G_e*G_c$ as well as factorising the equation where possible as can be seen in figure \ref{fig:BJTCollector}.    
\begin{figure}[h]
    \caption{BJT Collector Coefficient Generator}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTCollector.png}
    \label{fig:BJTCollector}
\end{figure}
After voltages have been calculated in a circuit the BJT is also required to have a method to calculate the current passing through it. Unlike the other components the BJT GetCurrent method return a vector<double> as opposed to a double. The fist value in the vector represents the current going into the collector, the second the base, and the third the emitter. When the coefficients for each node were calculated earlier when calculating voltages they were stored in three vectors. This means that using the voltages the currents can quickly be calculated, this is shown in figure \ref{fig:BJTCurrent}. 
\begin{figure}[h]
    \caption{BJT Current Generator}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTCurrent.png}
    \label{fig:BJTCurrent}
\end{figure}
The BJT used within our simulation was the 2N2222, which has values of $I_S = 10^{-14}$, $R_b = 10$, $R_c = 0.3$, $R_e - 0.2$, $\beta_r = 3$ and $\beta_f = 200$.
\newpage

\section{Analysis Algorithms}\label{sec:AnalysisAlgorithms}
\subsection{Parser}\label{ssec:parser}
The role of Parser.hpp is to read an input text file (compatible with a SPICE netlist) that defines the circuit and the simulation.\medbreak
In the input file each component has a unique designator letter \bigbreak
Reference:\ref{ss}
\begin{figure}[h]
    \caption{Components input format}
    \centering
    \includegraphics[width=1\textwidth]{images/components_input_format.PNG}
    \label{fig:ComponentsInputFormat}
\end{figure}
Firstly Parser.hpp constructs an empty Circuit instance, it then peeks the first character of each line of the input file.
\begin{itemize}
\item If the first character is a \textit{designator letter}, it constructs a new Component in the heap with the aid of read\_value and read\_node\_number functions, then it updates the Circuit instance by using the Circuit::add\_component function.
\item If the first string of the line is \textit{.tran} it then proceeds to run a Transient analysis of the Circuit
\item If the first character is a \textit{*} it ignores the line because it is a comment
\item If the first string of the line is \textit{.end} it closes the input file
\end{itemize}



\subsection{KCL Solver}
The role of KCL\_Solver is to solve for the Circuit voltages at a given instant in time by constructing a conductance matrix. The matrix requires that all components have a linear relationship between current and voltage as it uses linear algebra to solve the circuit. At the start of our project a rapid prototype of the algorithm was made that functioned correctly but wasn't designed to be as efficient as possible. This was necessary as it allowed other sections of the program that needed the algorithm to be worked on without having to wait for a final version. The KCL Solver algorithm needs to be particularly fast as it may be run by the Transient Solver algorithm many times each time step meaning it is the biggest bottle neck to speed.
\subsubsection{Rapid Prototype Model}
This model was deigned to be quick to make and simple to add more components to. However, it has many areas where it is repeating calculation resulting in slower speeds.\\ The algorithm takes a circuit object by reference and modifies the voltages inside of the object. Firstly it iterates through each of the nodes in the vector of nodes within the circuit, each time iterating through each nodes vector of component objects. At each component the algorithm stores the coefficients describing the current coming from that component depending on the voltages at each node, as well as the constant current coming from the component. These values are added to a vector of doubles where each index represents the corresponding node. For instance a resistor with an anode of node 1 and a cathode of node 2 would add its conductance to the second index of the vector and the negative of its conductance to the third of the vector, if we are looking at the cathode. Once all the components have been iterated through this vector is inserted as a row in a matrix corresponding to that nodes index. This forms the conductance matrix which is used to calculate the voltages as described earlier.\\
In the case of voltage sources however, this gets a little more complicated. Since the current through the voltage source can't be calculated using the voltage across it an iterative technique was used to find the current coming into the voltage source. The function that creates the vector of coefficients would be called on the opposite node of the voltage source, but this time ignoring the connection to the voltage source. This vector of doubles could then be modified by replacing all instances of the opposite node with the current node minus the voltage of the voltage source. Once complete this vector of doubles can be added to the current vector of doubles for the node and the iteration through the components continues. 

\subsubsection{optimized model}
The final version of the KCL solver has been designed to be as fast and efficient as possible


















\paragraph{nodal analysis}
In order to perform a transient simulation we evaluated the node voltages of the circuit at each successive instant in time. This is done by applying KCL at each node in the Circuit and then solve the set of simultaneous equations obtained.\bigbreak
To solve the problem computationally we resorted to linear algebra and decided to write the set of simultaneous equations in the following form
\begin{figure}[h]
    \caption{Circuit analysis equations}
    \centering
    \includegraphics[width=5cm]{images/Conductance_Matrix.PNG}
    \label{fig:ConductanceMat}
\end{figure}

where, starting form the left, we have the conductance Matrix, the vector containing the voltages at each node and the vector containing the currents flowing into each node
\subparagraph{linear components}
For Resistor, Voltage-Controlled-Current-Source and Current source the approach was to insert the defining equation of the given component in the set of linear equations. 
\subparagraph{non-linear components}
For Capacitor, Inductor and Diode we first had to linearize the respective defining equation.
This was done by replacing each component in the circuit by its respective linear companion model (see \cite{LinearCompanionModels}) and use the new linear equations to solve the matrix. By extension, also BJT is handled in this way because we chose to use Ebers-Moll model to implement it.\bigbreak

Note that linear Companion models have been preferred to numerical integration by trapezoidal rule for Capacitor and Inductor because the former method is faster and produces more accurate results.
\subparagraph{voltage components}
Since voltage components have infinite conductance a different approach had to be undertaken. Their equation is written in the matrix after all the other components have been dealt with. The row corresponding to the anode of the component is added to the row corresponding to the cathode creating a supernode. Then row corresponding to the anode is replaced with the defining equation of the voltage component.
\begin{figure}[h]
    \caption{Circuit analysis equations containing a voltage source}
    \centering
    \includegraphics[width=5cm]{images/Voltage_source_matrix.PNG}
    \label{fig:VoltCompConductanceMat}
\end{figure}













\paragraph{constructing the conductance Matrix}
The general nodal analysis algorithm implies writing a KCL equation for each node of the circuit. KCL performed at node n resulted in row n of the matrix and index n of the vector of currents being modified. A complete set of equations would look like this \bigbreak

\begin{bmatrix}
a_{00} & a_{01} & a_{02} & a_{03}\\
a_{10} & a_{11} & a_{12} & a_{13}\\
a_{20} & a_{21} & a_{22} & a_{23}\\
a_{30} & a_{31} & a_{32} & a_{33}
\end{bmatrix}
\cdot
\begin{bmatrix}
v_{0} \\
v_{1} \\
v_{2} \\
v_{3}
\end{bmatrix}
=
\begin{bmatrix}
i_{0} \\
i_{1} \\
i_{2} \\
i_{3}
\end{bmatrix}

\bigbreak
Since v\verb|_|0 is assumed to be GND, Column 0 and Row 0 are then removed from the set of linear equations. This produces a \textit{reduced set of linear}
\bigbreak


\begin{bmatrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & a_{22} & a_{23}\\
 a_{31} & a_{32} & a_{33}
\end{bmatrix}
\cdot
\begin{bmatrix}
v_{1} \\
v_{2} \\
v_{3}
\end{bmatrix}
=
\begin{bmatrix}
i_{1} \\
i_{2} \\
i_{3}
\end{bmatrix}

\bigbreak
This operation, necessary to make the system solvable, makes indexes of the form $a_{0n}$ and $a_{n0}$ invalid. In order to avoid creating a matrix and then resizing it (very slow operation), we decided to instantiate directly a matrix of the right size and adjust the filling to obtain an equivalent result. This implied writing every element at index $a_{nn}$ to index $a_{n-1,n-1}$ and omit the operation if it resulted in an invalid index being written.

\paragraph{filling the conductance Matrix}
Each Current component within our model can be thought as a combination of Resistor and Current Source. This means that a Current component can be represented mathematically as some conductances in the conductance Matrix and currents in the vector of currents.\\
The information of where the coefficients should be written is encoded in the \textit{anode} and \textit{cathode} of the component and what should be written is specified by the kind of component.\bigbreak

Firstly, we iterate through the Circuit::vector$<$Component*$>$ to know how the equations need to be set up. We have made the design choice of using \textit{pointers} as opposed to object instances for the following reasons
\begin{itemize}
  \item They allow maximum exploitation of the hierarchical design. Component* can be downcasted to derived Components (e.g. Resistor*,Inductor*...) thus allowing us to use derived classes' methods.
  \item They allow Components to be instantiated in the Heap, thus enabling us to have a single instance of a given Component that each macro-block in our design can refer to. For instance components are constructed by Parser (see \ref{ssec:parser}) and then processed by KCL solver
  \item They avoid copy-constructing objects producing therefore a significant speed increase of our program
\end{itemize}

Note that the following section describes how to insert coefficients in the non reduced matrix. Our code then maps each coefficient to the right position in the reduced matrix\bigbreak
The convention followed is that the current going out of each node must sum up to 0.\\
If the component is a Resistor then we know that its characteristic equation is $Current = \frac{V_{Anode} - V_{Cathode}}{R}$. We look at row Anode and write $\frac{1}{R}$ at $a_{Anode,Anode}$  and write $-\frac{1}{R}$ at $a_{Anode,Cathode}$ . Symmetrically we then look at row Cathode and write $\frac{1}{R}$ at $a_{Cathode,Cathode}$  and write $-\frac{1}{R}$ at $a_{Cathode,Anode}$.\\
If the component is a Current Source then we look a index anode in the current vector and write +Current. We then look at index cathode in the current vector and write -Current.\\
This approach is extended for Current Components. For Diodes and BJTs specific implementation see relative sections //ADD LINK

\subparagraph{Voltage Components}
When encountered, Voltage Components are stored in a vector to be processed after Current Components and BJTs are handled.\bigbreak
If the component is a Voltage Source or an AC Voltage Source then we know its characteristic equation is $V_{anode}-V_{cathode}=V_{src}$. We create a supernode equation by adding row anode to row cahtode and index anode to index cathode in the vector of currents. We then look at row anode and write 1 at $a_{Anode,Anode}$ and write -1 at $a_{Anode,Cathode}$. We also write $V_{src}$ at index anode of the vector of currents.\\ For Voltage Controlled Voltage Sources the principle is extended by adding the additional terms included in the characteristic equation.\bigbreak
\paragraph{Dense vs Sparse Matrix}






\newpage

\subsection{Transient Solver}
When non-linear components such as BJT's and diodes are present in a circuit solving the circuit using linear algebra is no-longer possible. Due to the complexity of diode and BJT equations the method used to solve these non-linear circuits is the iterative Newton-Raphson method. The equation that describes the iterative method is:
\bigbreak $x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$\bigbreak
By repeating this iteration $x_n$ may converge such that $f(x_n) = 0$
Originally we considered that due to the presence of many node voltages in a circuit and a diode current being dependent on two of those voltages a multi-variable method would have to be used. We researched how to modify the above equation for multi variable equations and found a lecture\cite{mulitvariableNR} describing the use of a Jacobian matrix. We tried implementing this method by giving each current component a function that returns a vector storing the partial derivatives of its current with respect to each current. However, we where never able to get this method to converge correctly with diodes, with the method also adding a lot of extra code and computation. Having tried this method we then found after more research that we could describe the current through the diode as a function of the voltage across it which is only one variable\cite{LinearCompanionModels}, so the use of multi-variable iteration was not needed. In order to solve the diode using Newton-Raphson we need to form an KCL equation that is equal to 0. Doing KCL at the diodes anode we have the equation:
\bigbreak $I_d - I_{in} = 0$\bigbreak
Where $I_in$ is the current entering the diode and $I_d$ is the current due to the diode current equation. Combining this with Newton-Raphson gives:
\bigbreak $x_{n+1} = x_n - \frac{I_d - I_{in}}{\frac{d I_d}{d V_d}}$\bigbreak
The Newton Raphson method the function each iteration as a linear function and so a diode is going to need to be modeled as a resistor and current source in parallel as any linear voltage current relationship can be modelled as this, (apart from those with an infinite gradient). I we consider a diode as a current source in parallel with a resistor we can again do KCL at its anode to form the equation. 
\bigbreak $V_d*G_l + I_l - I_{in} = 0$ Where $G_l$ and $I_l$ are the conductor and current source values.\bigbreak
We want to find a value of $G_l$ and $I_l$ such that if we solve the circuit using the KCL solver algorithm the voltage across the diode will be $V_{n+1}$
\bigbreak
Thus if we rearrange the Newton-Raphson equation we have:\bigbreak
$x_{n+1}*\frac{d I_d}{d V_d} = x_n*\frac{d I_d}{d V_d} - I_d + I_{in}$\bigbreak
From this we can see that if we make $G_l = \frac{d I_d}{d V_d}$ and $I_l = I_d - x_n*\frac{d I_d}{d V_d}$ when the equation is solved the voltage across the diode will be $V_{n+1}$\bigbreak
If we keep repeating this method of setting the value of G and I for each diode and then solving the circuit and then resetting the values the circuit should converge to the correct values. To complete the iterations though we need some way of telling when the circuit has converged to an acceptable accuracy. 
Within Spice two parameters are used to measure this convergence.
\begin{itemize}
    \item RELTOL
    \item ABSTOL
\end{itemize}
Spice combines these two parameters within the inequality $|v_{n+1}-x_n| < RELTOL*|x_n| + ABSTOL$.\\
RELTOL measures the relative change in the voltage and ABSTOL is present as near 0V $RELTOL*|x_n|$ may become too small. Each iteration of our algorithm each of the node voltages is compared using this inequality to the previous voltage and if all the inequalities return true the algorithm finishes. A maximum number of iterations is set so that the program can't get stuck in an infinite loop. Within our program the max iterations was set to 1000 as we found that a correct circuit usually has a max iterations of a few hundred on the first time step and so this provides room for that occur. We set RELTOL and ABSTOL to values of $10^{-3}$ and $10^{-12}$ respectively. This provided a trade off between accuracy and speed of our program. If higher accuracy is needed RELTOL should be decreased. 
\bigbreak
In order to implement this algorithm the flow diagram shown in figure \ref{fig:transient}. The entire algorithm is contained within one function called TransientSolver. This function takes a circuit object by reference and modifies its voltages to the correct voltages given components in the circuit or exits the program if the maximum iterations is reached. This means that the starting guess for the voltage is the voltages from the previous time instance meaning that they are very close to the new voltages. This results in very few iterations normally being needed. Only the first iteration with starting guesses of 0V takes many iterations under normal use. \\

The algorithm runs within a while loop, starting by looping through all the components and setting the linear current and conductance of all diodes and BJT's. As BJT's are simply modelled as containing two diodes they converge in the same manner as diodes do. The algorithm then saves the circuit voltages in a vector before running the KCL solver algorithm on the circuit. After this it compares the old voltages with new and breaks the while loop if complete.  

\begin{figure}[h]
    \caption{Transient Solver Algorithm}
    \centering
    \includegraphics[width=0.5\textwidth]{images/TransientSolverAlgorithm.png}
    \label{fig:transient}
\end{figure}

\newpage

\subsection{DC Operating Point Analysis}
The DC operating point analysis is required to find the starting node voltages for the transient analysis. It is very similar to the transient analysis and uses most of the same code base. The difference is that it only looks at a single point in time as well as assuming all capacitors to be open circuits, inductors to short circuits and ac sources to be at their dc bias point. In order to implement this the linear conductance and current of the capacitors are all left at their default value of 0, essentially making them open circuits. The same is used for the ac sources with their default values being their dc bias.\\Unfortunatly inductors are a little more complicated to implement as short circuits. In order to do this the same method as used in the final KCL solver for treating voltage sources was used as a short circuit can be thought of as a 0V voltage source. To allow for this a boolean parameter was added to the KCL solver function with a default values of false. When this is set to true all inductors are treated in this way, forming super nodes.\\
With this code added to the KCL Solver the OP analysis function simply has to check if the circuit is linear or not and run the KCL solver or the transient solver algorithm respectively. 
\newpage
\subsection{Calculate Currents}
\subsection{Transient Analysis}
NOT FINISHED COME BACK WHEN COMPLETE.
The transient Analysis function controls the overall simulation elements, it is responsible for updating the values of linear components at each time instance and writing the node voltages and component currents to output files once KCL or transient solver has run. The transient analysis inputs are: 
\begin{itemize}
    \item The Circuit.obj generated by parser
    \item The number of time steps (calculated by taking Timeperiod/Length of Time step) 
    \item The time period / end time from 0 
\end{itemize}
The function follows this design:

\begin{figure}[H]
\centering
\includegraphics[width =0.5\textwidth]{ images/TranAna.PNG}
\label{fig:TranAna} 
\caption{Transient Analysis algorithm flow diagram}
\end{figure}
The set conductance function simply loops though each component in the Circuit and sets their conductance based on the parameter of delta time see inductor and capacitor models for further detail.
\break
The update node voltages function goes through , first updates the value of variable voltage sources such as the AC Voltage source at the current time. It then runs the Transient solver for every non-linear component and the KCL solver for every linear component. After having performed these functions the Node Voltage To File is called which prints the current Node values at that time instance into





\newpage
\section{Application Features and Innovation}
\subsection{QT Container and Application}
Biggest innovations: 
QT
Used derivations to eliminate mathematical complexity and faster implementation: In diode and BJT. 



\section{Testing and Evaluation}
\subsection{Testing Diodes}
\subsubsection{Test 1}
The accuracy of circuits containing diodes is dependent on the error that we set with the RELTOL and ABSTOL parameters within our program. The values of RELTOL that we used was $10^{-3}$ as so our relative accuracy should be in the region of $0.1\%$. This accuracy is not possible at values very close to 0V and the ABSTOL parameter sets a limit on the maximum finite accuracy of the simulation. When testing our diodes we continued to aim for an average relative accuracy of $0.5\%$ as a bench mark. We found that in order to achieve this the presence of connection resistances in the diode model were necessary especially when other low resistances are present in the circuit. \\
A simple test of the diode in series with a resistor as shown in figure \ref{fig:DiodeTest1} demonstrates the diode functioning correctly. This table shows the spice output compared to our simulator output. As can be seen our accuracy is far within the margin set. The diode also behaves as expected when connected to ground, voltage sources and current sources with similar accuracy.  
\begin{center}
\begin{tabular}{ ||c| c ||c ||}
\hline
 Spice & Simulator & Percentage Error \\ 
 \hline
 2.86753 & 2.86746 & 0.0024 \\  
 2.13247 & 2.13254 & 0.0034 \\   
 \hline
\end{tabular}
\end{center}
The current was also tested and the relative errors are shown compared to spice in the table.
\begin{center}
\begin{tabular}{ ||c| c ||c ||}
\hline
 Spice & Simulator & Percentage Error \\ 
 \hline
 21.3247 & 21.3254 & 0.0033 \\  
 \hline
\end{tabular}
\end{center}
\begin{figure}[h]
    \caption{Diode Test 1}
    \centering
    \includegraphics[width=0.5\textwidth]{images/DiodeTest1.png}
    \label{fig:DiodeTest1}
\end{figure}
\subsubsection{Test 2}
We also tested our diode in full wave rectifier arrangement to demonstrate its accuracy in more complex circuits. The circuit used is the one shown in figure \ref{fig:DiodeTest2}. Testing was more complicated as we needed to compare with the spice output at different time steps. As spice doesn't use constant time steps unlike our algorithm we cannot simply compare the voltage at each time step. In order to measure the accuracy we created a python script that interpolates the data from spice to give a voltage at each time step. In order to do this we assumed each of the voltage changes in the spice output to be linear. This can then be compared to our output and taking the average error across all the time steps. As our value of ABSTOL was $10^{-12}$ any value of voltage lower than this didn't have its error compared. We found that the average error for the voltage across the resistor across all time steps was 0.043\% and the maximum error was 1.2\%. The graphical output of our rectifier can be seen in figure \ref{fig:FullWaveRec} and is as expected from a full wave rectifier. Our analysis was run over 5 seconds with 0.01 second time steps. 
\begin{figure}[h]
    \caption{Diode Test 2}
    \centering
    \includegraphics[width=0.5\textwidth]{images/DiodeTest2.png}
    \label{fig:DiodeTest2}
\end{figure}
\begin{figure}[h]
    \caption{Full Waver Rectifier Output}
    \centering
    \includegraphics[width=0.5\textwidth]{images/FullWaveRec.png}
    \label{fig:FullWaveRec}
\end{figure}
\newpage
\subsection{Testing BJT}
To test the BJT working the circuit shown in figure \ref{fig:BJTTest1} was used. The table below shows the voltage from the spice simulation and our simulation as well as the relative error. The error is greater than that found in the diode bu still within an acceptable margin. 
\begin{center}
\begin{tabular}{ ||c| c ||c ||}
\hline
 Spice & Simulator & Percentage Error \\ 
 \hline
 4.98968 & 4.98926 & 0.0084 \\  
 4.29682 & 4.29495 & 0.043 \\   
 \hline
\end{tabular}
\end{center}
\begin{figure}[h]
    \caption{BJT Test}
    \centering
    \includegraphics[width=0.5\textwidth]{images/BJTTest1.png}
    \label{fig:BJTTest1}
\end{figure}

\subsection{Testing Capacitor Model}
When testing energy storage devices it was expected that there would be more error than found when testing other components due to the effects of integration error. We first tested a capacitor connected to an ac source as shown in figure .
\section{Final Evaluation}

\newpage



\bibliographystyle{plain}
\bibliography{bibliography.bib}

\end{document}
